[
	{
		"testcasename": "CodingOp",
		"testname": "IndentSelection",
		"filepath": "tests/google_tests/coding_operation_tests.cpp",
		"filename": "coding_operation_tests.cpp",
		"body": "TEST(CodingOp, IndentSelection) {\r\n     \r\n     // DocumentUtils::performCodingOperation\r\n    {\r\n        char *text = const_cast<char *>(u8R\"(\r\n{\r\n\"jsonrpc\":\"2.0\",\r\n                    \"jsonrpc2\":\"2.0\",\r\n                                        \"jsonrpc3\": {\r\n\"a\":\"日本語\"\r\n}\r\n}\r\n)\");\r\n\r\n        char *autoIndentedText = const_cast<char *>(u8R\"(\r\n{\r\n    \"jsonrpc\":\"2.0\",\r\n    \"jsonrpc2\":\"2.0\",\r\n    \"jsonrpc3\": {\r\n        \"a\":\"日本語\"\r\n    }\r\n}\r\n)\");\r\n        auto *document = Alloc::newDocument(DocumentType::JsonDocument, nullptr);\r\n        DocumentUtils::parseText(document, text, strlen(text));\r\n        EXPECT_EQ(document->context->syntaxErrorInfo.hasError, true);\r\n\r\n        DocumentUtils::generateHashTables(document);\r\n\r\n        auto *rootJson = Cast::downcast<JsonObjectStruct*>(document->firstRootNode);\r\n        auto *item = rootJson->firstKeyValueItem->keyNode;\r\n        if (item) {\r\n            EXPECT_EQ(item->vtable, VTables::JsonObjectKeyVTable);\r\n            DocumentUtils::performCodingOperation(\r\n                CodingOperations::AutoIndentSelection\r\n                , document, Cast::upcast(document->firstRootNode), Cast::upcast(&document->endOfFile));\r\n        }\r\n\r\n\r\n        char *treeText = DocumentUtils::getTextFromTree(document);\r\n        EXPECT_EQ(std::string{ treeText }, std::string{ autoIndentedText });\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    {\r\n     //   DocumentUtils::performCodingOperation CodingOperations::AutoIndentForSpacingRule\r\n        {\r\n            char *text = const_cast<char *>(u8R\"(\r\n{\r\n\"jsonrpc\":\"2.0\",\r\n                    \"jsonrpc2\":\"2.0\",\r\n                        \"jsonrpc3\": {\r\n    \"a\":\"日本語\"\r\n}\r\n}\r\n)\");\r\n\r\n\r\n            char *autoIndentedText = const_cast<char *>(u8R\"(\r\n{\r\n    \"jsonrpc\":\"2.0\",\r\n                    \"jsonrpc2\":\"2.0\",\r\n                        \"jsonrpc3\": {\r\n        \"a\":\"日本語\"\r\n    }\r\n}\r\n)\");\r\n\r\n            auto *document = Alloc::newDocument(DocumentType::JsonDocument, nullptr);\r\n            DocumentUtils::parseText(document, text, strlen(text));\r\n            EXPECT_EQ(document->context->syntaxErrorInfo.hasError, true);\r\n\r\n            DocumentUtils::generateHashTables(document);\r\n\r\n            auto *rootJson = Cast::downcast<JsonObjectStruct*>(document->firstRootNode);\r\n            auto *item = rootJson->firstKeyValueItem->keyNode;\r\n            if (item) {\r\n                EXPECT_EQ(item->vtable, VTables::JsonObjectKeyVTable);\r\n            }\r\n\r\n            DocumentUtils::performCodingOperation(\r\n                CodingOperations::AutoIndentForSpacingRule\r\n                , document, Cast::upcast(document->firstRootNode), Cast::upcast(&document->endOfFile));\r\n\r\n            char *treeText = DocumentUtils::getTextFromTree(document);\r\n            EXPECT_EQ(std::string{ treeText }, std::string{ autoIndentedText });\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n    //DocumentUtils::performCodingOperation\r\n\r\n    {\r\n        char *text = const_cast<char *>(u8R\"(\r\nclass A\r\n{\r\nclass B\r\n{\r\n\r\n}\r\n}\r\n)\");\r\n\r\n        char *autoIndentedText = const_cast<char *>(u8R\"(\r\nclass A\r\n{\r\n    class B\r\n    {\r\n\r\n    }\r\n}\r\n)\");\r\n        auto *document = Alloc::newDocument(DocumentType::CodeDocument, nullptr);\r\n        DocumentUtils::parseText(document, text, strlen(text));\r\n        DocumentUtils::performCodingOperation(\r\n            CodingOperations::AutoIndentSelection\r\n            , document, Cast::upcast(document->firstRootNode), Cast::upcast(&document->endOfFile)\r\n        );\r\n\r\n\r\n        char *treeText = DocumentUtils::getTextFromTree(document);\r\n        EXPECT_EQ(std::string{ treeText }, std::string{ autoIndentedText });\r\n    }\r\n\r\n\r\n\r\n\r\n}\r\n\r\n"
	},
	{
		"testcasename": "cplusplus_test",
		"testname": "stringstream_",
		"filepath": "tests/google_tests/cplusplus_test.cpp",
		"filename": "cplusplus_test.cpp",
		"body": "TEST(cplusplus_test, stringstream_) {\r\n    /*\r\n    // Your imaginary buffer\r\n    char    buffer[] = \"A large buffer we don't want t\\n\\no copy but use in a stream\";\r\n\r\n    // An ordinary stream.\r\n    std::stringstream   str;\r\n    std::stringstream   str2;\r\n    str << \"WWOWOWOWO\\n\\nWowowo\";\r\n\r\n    // Get the streams buffer object. Reset the actual buffer being used.\r\n    str.rdbuf()->pubsetbuf(buffer, sizeof(buffer));\r\n    //str << \"WWOWOWOWO\\n\\nWowowo\";\r\n\r\n    std::copy(std::istreambuf_iterator<char>(str),\r\n        std::istreambuf_iterator<char>(),\r\n        std::ostream_iterator<char>(std::cout)\r\n    );\r\n\r\n    std::cout << \"jfiowe\\n\\njfoiaw\";\r\n    */\r\n\r\n\r\n    std::stringstream log;\r\n\r\n    bool stopped = false;\r\n    std::mutex mtx;\r\n\r\n    auto &sstream = log;\r\n    auto worker_thread = std::thread([&]() {\r\n        std::vector<int> v;\r\n        while (!stopped) {\r\n            //printf(\";\");\r\n//\t\t\tstd::this_thread::sleep_for(std::chrono::microseconds(1000));\r\n            {\r\n                std::lock_guard<std::mutex> lg{ mtx };\r\n                std::copy(std::istreambuf_iterator<char>(sstream),\r\n                    std::istreambuf_iterator<char>(),\r\n                    std::ostream_iterator<char>(std::cout)\r\n                );\r\n            }\r\n        }\r\n    });\r\n\r\n    for (int i = 0; i < 10; i++) {\r\n        std::lock_guard<std::mutex> lg{ mtx };\r\n\r\n        log << u8\"日本語a\";\r\n        log << \"C\";\r\n\r\n        // +i % 25);\r\n        // std::this_thread::sleep_for(std::chrono::microseconds(2000));\r\n    }\r\n\r\n\r\n    //log << std::feof(nullptr);\r\n    log << '\\0';\r\n    stopped = true;\r\n    worker_thread.join();\r\n\r\n    EXPECT_EQ(100, 100);\r\n}\r\n\r\n"
	},
	{
		"testcasename": "cplusplus_test",
		"testname": "test1",
		"filepath": "tests/google_tests/cplusplus_test.cpp",
		"filename": "cplusplus_test.cpp",
		"body": "TEST(cplusplus_test, test1) {\r\n    {\r\n        char a = -122;\r\n        unsigned char b = a;\r\n#if defined(__aarch64__) && defined(__ANDROID__)\r\n       EXPECT_TRUE((int)a == (int)b);\r\n#else\r\n        EXPECT_TRUE((int)a != (int)b);\r\n#endif\r\n\r\n        EXPECT_FALSE(3 == 5);\r\n    }\r\n\r\n\r\n    //auto ret = TestUtil::testUtf8Text();\r\n\r\n    //EXPECT_EQ(5, ret);\r\n\r\n    //arrange\r\n    //act\r\n    //assert\r\n    //EXPECT_EQ(1, 1) << \"Vectors x and y are of unequal length\";;\r\n\r\n    //ASSERT_TRUE(true);\r\n\r\n    EXPECT_EQ(20, 20);\r\n    EXPECT_EQ(100, 100);\r\n\r\n    /*\r\n        EXPECT_EQ(Formula::bla(0), 0);\r\n        EXPECT_EQ(Formula::bla(10), 20);\r\n        EXPECT_EQ(Formula::bla(50), 100);\r\n     */\r\n}\r\n\r\n"
	},
	{
		"testcasename": "cplusplus_test",
		"testname": "ArmAssemblyTest2",
		"filepath": "tests/google_tests/cplusplus_test.cpp",
		"filename": "cplusplus_test.cpp",
		"body": "TEST(cplusplus_test, ArmAssemblyTest2) {\r\n    #ifdef __aarch64__\r\n\r\n    int a = 1;\r\n    int b = 2;\r\n    int c = 0;\r\n\r\n    c = add(a, b);\r\n\r\n    printf(\"Result of %d + %d = %d\\n\", a, b, c);\r\n    EXPECT_EQ(c, 3);\r\n    EXPECT_EQ(sysconf(_SC_NPROCESSORS_CONF), 8);\r\n    EXPECT_EQ(sysconf(_SC_NPROCESSORS_ONLN), 8);\r\n\r\n    //register void *sp asm(\"sp\");\r\n    // void* p2 = NULL;\r\n\r\n\r\n    //EXPECT_EQ(sp, (void*)&p2);\r\n    #endif\r\n}\r\n#ifdef __aarch64__\r\n\r\nstatic long add(long i, long j)\r\n{\r\n    long res = 0;\r\n    __asm (\"ADD %[result], %[input_i], %[input_j]\"\r\n    : [result] \"=r\" (res) : [input_i] \"r\" (i), [input_j] \"r\" (j)\r\n    );\r\n\r\n    //int address = 0;\r\n    /*\r\n     *\r\n    __asm (\"STR sp, [%0]\\n\\t\"\r\n    : \"=r\" ( address)\r\n    );\r\n     */\r\n     /*\r\n         __asm (\"mov %0, sp\\\\n\\\\t\"\r\n         : \"=r\" (address)\r\n         );\r\n      */\r\n\r\n\r\n    //long a = 324;\r\n    //EXPECT_EQ(address, 3);\r\n\r\n    return res;\r\n}\r\n#endif\r\n\r\n"
	},
	{
		"testcasename": "cplusplus_test",
		"testname": "printFoo",
		"filepath": "tests/google_tests/cplusplus_test.cpp",
		"filename": "cplusplus_test.cpp",
		"body": "TEST(cplusplus_test, printFoo) {\r\n    \r\n    int sleepings = 0;\r\n    sleepings = sleepings | (1 << 0);\r\n    EXPECT_EQ(sleepings, 1);\r\n\r\n    sleepings = sleepings | (1 << 0);\r\n    sleepings = sleepings | (1 << 1);\r\n\r\n    EXPECT_EQ(sleepings, 3);\r\n\r\n    sleepings = sleepings & ~(1 << 0);\r\n    sleepings = sleepings & ~(1 << 1);\r\n\r\n    EXPECT_EQ(sleepings, 0);\r\n\r\n    std::ostringstream output;\r\n    printFoo(output);\r\n\r\n    for (int ki = 0; ki < 100; ki++) {\r\n        //std::this_thread::sleep_for(std::chrono::milliseconds{1});\r\n        //GLOG << std::endl;\r\n\r\n        for (int i = 0; i < 100; i++) {\r\n            //std::this_thread::sleep_for(std::chrono::milliseconds{8});\r\n            //auto *ains = new A();\r\n            //delete ains;\r\n\r\n            //GLOG << i << \",\";\r\n        }\r\n    }\r\n    // Not that familiar with gtest, but I think this is how you test they are\r\n    // equal. Not sure if it will work with stringstream.\r\n    //EXPECT_EQ(output.str(), \"Successful\\n\");\r\n\r\n\r\n    GLOG << \"awfwe 23\";// << std::endl;\r\n\r\n    printf(\"\\nfwe\\n\");\r\n    return;\r\n\r\n    // For reference, this is the equivalent assert in mstest\r\n    // Assert::IsTrue( output == \"Successful\" );\r\n}\r\n\r\n"
	},
	{
		"testcasename": "cplusplus_test",
		"testname": "ThreadQueue",
		"filepath": "tests/google_tests/cplusplus_test.cpp",
		"filename": "cplusplus_test.cpp",
		"body": "TEST(cplusplus_test, ThreadQueue) {\r\n    GLOG << \"started: \";// << std::fflush;\r\n\r\n    auto start = std::chrono::high_resolution_clock::now().time_since_epoch();\r\n\r\n    ThreadPool tp;\r\n    tp.init();\r\n    tp.start();\r\n\r\n\r\n    std::thread thread1([]() {\r\n\r\n    });\r\n\r\n    std::this_thread::sleep_for(std::chrono::milliseconds{ 1000 });\r\n\r\n    thread1.join();\r\n\r\n    auto elapsed = std::chrono::high_resolution_clock::now().time_since_epoch() - start;\r\n\r\n    auto microseconds = std::chrono::duration_cast<std::chrono::microseconds>(elapsed).count();\r\n    auto diff = microseconds * 1000;\r\n\r\n\r\n    for (int i = 0; i < threads_size; i++) {\r\n        tp.threads[i]->doStop();\r\n    }\r\n\r\n    for (int i = 0; i < threads_size; i++) {\r\n        tp.threads[i]->join();\r\n    }\r\n\r\n\r\n    GLOG << diff << \"diff!\\n\" << \"\\n\";\r\n\r\n    long long count = 0;\r\n    for (int i = 0; i < threads_size; i++) {\r\n        count += tp.threads[i]->set_count;\r\n        std::cout << i << \": \" << tp.threads[i]->set_count << \": \\n\";\r\n    }\r\n\r\n    long long count_b = 0;\r\n    {\r\n        for (int i = 0; i < thread_queue_size; i++) {\r\n            GLOG << \" \\n\";\r\n\r\n            //count_b += tp.thread_queue[i]->lastRunNode.load()->idx;\r\n\r\n            auto *firstNode = POINTER_LOAD(tp.thread_queue[i]->doingRunNode);\r\n            auto *lastNode = POINTER_LOAD(tp.thread_queue[i]->lastRunNode);\r\n\r\n            GLOG << \"queue lastNode->nodeIndex = \" << FormatWithCommas(tp.thread_queue[i]->lastNodeIndex) << std::endl;\r\n\r\n\r\n            int count_temp = -1;\r\n            while (firstNode) {\r\n                count_temp++;\r\n                //printf(\"%d,\", leftNode->nodeIndex.load());\r\n                if (firstNode == lastNode) {\r\n                    GLOG << \"lastNode->nodeIndex = \" << lastNode->nodeIndex << std::endl;\r\n                    break;\r\n                }\r\n                firstNode = firstNode->next;\r\n            }\r\n\r\n            count_b += count_temp;\r\n            //\t\tstd::cout << i << \":: \" << tp.thread_queue[i]->lastRunNode.load()->idx << \"\\n\";// << aobj->gf;\r\n        }\r\n\r\n        GLOG << count << \": count by each thread: \" << \" \" << \"\\n\";\r\n        GLOG << count_b << \": last node counter: \" << \"   !\\n\" << \"\\n\";\r\n        GLOG << diff << \"diff         !\\n\" << \"\\n\";// << aobj->gf;\r\n    }\r\n\r\n    EXPECT_EQ(count, count_b);\r\n    //TestUtil::testUtf8Text();\r\n\r\n\r\n    //std::cout << \"\\set_count = \" << set_count_b << \"\\n\";\r\n    //std::cout << \"\\nconflict = \" << conflict << \"\\n\";\r\n    //std::cout << \"\\nconflict2 = \" << conflict2 << \"\\n\";\r\n\r\n    //_getchar_nolock();\r\n\r\n    if (managed_cmake_test == false) {\r\n        EXPECT_EQ(\"\", \"Fail to see log\");\r\n    }\r\n}\r\n\r\n"
	},
	{
		"testcasename": "concept",
		"testname": "wakeup_test",
		"filepath": "tests/google_tests/cplusplus_test.cpp",
		"filename": "cplusplus_test.cpp",
		"body": "TEST(concept, wakeup_test) {\r\n\r\n    constexpr int sleeping_thread_size = 2;\r\n\r\n    static unsigned long long wakeups[sleeping_thread_size];\r\n    std::atomic<int> side[sleeping_thread_size];\r\n\r\n    static std::condition_variable_any main_sleeper_cond;\r\n    sleepings = 0;\r\n    stopped2 = false;\r\n\r\n\r\n    std::ostringstream output_stream;\r\n\r\n    std::vector<std::thread *> worker_threads;\r\n\r\n    for (int s = 0; s < sleeping_thread_size; s++) {\r\n\r\n        side[s].store(0);\r\n\r\n        wakeups[s] = 0;\r\n\r\n        auto worker_thread = new std::thread([](int index) {\r\n            std::mutex this_mtx;\r\n            std::unique_lock<std::mutex> sleeper_lock{ this_mtx };\r\n\r\n            while (true) {\r\n                bool first = true;\r\n                while (true) {\r\n                    auto l = sleepings.load();\r\n                    if (sleepings.compare_exchange_weak(l, l | (1 << index))) {\r\n                        break;\r\n                    }\r\n                    else {\r\n                        if (first == true) {\r\n                            first = false;\r\n                            //printf(\"[\");\r\n                        }\r\n                        //printf(\"w-%d,\",index);\r\n                    }\r\n                }\r\n\r\n                if (stopped2) {\r\n                    break;\r\n                }\r\n\r\n                //auto notified =\r\n                main_sleeper_cond.wait_for(sleeper_lock,\r\n                    std::chrono::milliseconds(1));\r\n\r\n                {\r\n                    bool first2 = true;\r\n                    while (true) {\r\n                        auto l = sleepings.load();\r\n                        if (sleepings.compare_exchange_weak(l, l & ~(1 << index))) {\r\n                            break;\r\n                        }\r\n                        else {\r\n                            if (first2 == true) {\r\n                                first2 = false;\r\n                                //printf(\"[\");\r\n                            }\r\n                            //printf(\"p-%d,\", index);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                //wakeupCount++;\r\n                wakeups[index]++;\r\n                /*\r\n                for (int j = 0; j < 1500; j++) {\r\n                    side[index].store(3335);\r\n                    //int *ml = new int{0};\r\n                    //delete ml;\r\n                    //throw 3;\r\n                }\r\n                */\r\n                //printf(\"%d,\", sleepings.load());\r\n\r\n                //std::this_thread::sleep_for(std::chrono::milliseconds(4));\r\n            }\r\n        }, s);\r\n\r\n        //worker_thread->detach();\r\n        worker_threads.push_back(worker_thread);\r\n    }\r\n\r\n    std::this_thread::sleep_for(std::chrono::microseconds(7000));\r\n\r\n    auto start = std::chrono::high_resolution_clock::now();\r\n\r\n    unsigned long long k = 0;\r\n    using newtype = unsigned int;\r\n    newtype loopCount = ARM ? 1000 * 70 : 1000 * 100;\r\n\r\n    auto current = int{};\r\n\r\n    for (newtype i = 0; i < loopCount; i++) {\r\n        // avoid memory intense access\r\n        if /*constexpr*/ (ARM) {\r\n            for (int p = 0; p < 2050; p++) {\r\n                current = p;\r\n            }\r\n        }\r\n        // atomic<>.load is relatively slow on ARM\r\n        if (sleepings.load(std::memory_order_relaxed) == 0) {\r\n            //k = i;\r\n            k++;\r\n            //tryWakeupCount++;\r\n        }\r\n        else {\r\n            //printf(\"%d,\", sleepings.load());\r\n            //main_sleeper_cond.notify_one();\r\n            main_sleeper_cond.notify_all();\r\n        }\r\n    }\r\n\r\n    stopped2 = true;\r\n\r\n    if (current > 0) {}\r\n\r\n    //std::chrono::system_clock::now();\r\n    auto elapsed = std::chrono::high_resolution_clock::now() - start;\r\n\r\n    auto nanoseconds = std::chrono::duration_cast<std::chrono::milliseconds>(elapsed).count();\r\n\r\n    for (int i = 0; i < sleeping_thread_size; i++) {\r\n        worker_threads[i]->join();\r\n    }\r\n\r\n    uint64_t totalWokeupCount = 0;\r\n    for (int i = 0; i < sleeping_thread_size; i++) {\r\n        totalWokeupCount += wakeups[i];\r\n    }\r\n\r\n\r\n    std::ostringstream output2;\r\n    //output2 << \"[error here]\" << current << std::endl;\r\n    printf(\"k = %llu \\n\", k);\r\n    auto one_op_nanosec = nanoseconds / static_cast<float>(loopCount);\r\n    auto wokeupCountPerMillisecond = (double)totalWokeupCount / (nanoseconds);\r\n\r\n    if (speed_test && !EMULATOR) { // thread switching is extremely slow on emulators\r\n        EXPECT_GT(wokeupCountPerMillisecond, ARM ? 10.0f : 5.0f);\r\n        printf(\"wokeupCountPerMillisecond = %f\\n\", wokeupCountPerMillisecond);\r\n    }\r\n\r\n\r\n    GLOG << \"wokeupCountPerMillisecond = \" << wokeupCountPerMillisecond;\r\n    if (speed_test) {\r\n        EXPECT_LT(one_op_nanosec, 43.0f);\r\n    }\r\n    //EXPECT_LT(k, loopCount * 20);\r\n\r\n    //EXPECT_LT(totalWokeupCount, tryWakeupCount);\r\n    //EXPECT_LT(totalWokeupCount, 3000);\r\n    //FAIL() << output2.str() << \":\" << milliseconds << \"ms\" << \",\" << k;\r\n\r\n}\r\n\r\n"
	},
	{
		"testcasename": "concept",
		"testname": "add_consume_test_win32",
		"filepath": "tests/google_tests/cplusplus_test.cpp",
		"filename": "cplusplus_test.cpp",
		"body": "TEST(concept, add_consume_test_win32) {\r\n\r\n    //#ifdef WIN32\r\n#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__)\r\n    //InterlockedCompareExchange64;\r\n    //InitializeConditionVariable;\r\n\r\n    HANDLE h;\r\n\r\n    //HANDLE sh = CreateEvent(NULL, TRUE, FALSE, TEXT(\"EVENT\"));\r\n\r\n    //対象のイベントオブジェクトを取得\r\n    //h = OpenEvent(EVENT_ALL_ACCESS, FALSE, TEXT(\"EVENT\"));\r\n    //シグナル状態になるまで待つ。\r\n    //WaitForSingleObject(h, 1000/*INFINITE*/);\r\n    //非シグナル状態にする。\r\n    //ResetEvent(h);\r\n\r\n\r\n\r\n    InitializeConditionVariable(&ConditionVar);\r\n    InitializeCriticalSection(&CritSection);\r\n\r\n\r\n    HANDLE hThread;\r\n    DWORD dwThreadId;\r\n    int64_t aval = 24;\r\n\r\n    // run thread\r\n    hThread = CreateThread(\r\n        NULL, // security attributes\r\n        100, // stack size\r\n        ThreadFunc, // function to invoke on the thread\r\n        NULL, // arguments\r\n        0, // create option (0 or CREATE_SUSPENDED)\r\n        &dwThreadId);// thread id\r\n\r\n\r\n    if (hThread > 0) {\r\n        // We are not gonna use this\r\n        //int *a = NULL;\r\n        //int *newValue = new int{ 3 };\r\n        //InterlockedExchangePointerNoFence((PVOID *)&a, newValue);\r\n\r\n\r\n        // CAS\r\n        int64_t newValue = 51234;\r\n        auto metValue = InterlockedCompareExchange64(&aval, newValue, 24);\r\n        EXPECT_EQ(metValue, 24);\r\n        if (metValue == 24) {\r\n            // succeed\r\n            EXPECT_EQ(aval, newValue);\r\n        }\r\n        else {\r\n            // failed, but a could be already equivalent to newValue thanks to other thread.\r\n        }\r\n\r\n\r\n\r\n        SuspendThread(hThread);\r\n        Sleep(2);\r\n        ResumeThread(hThread);\r\n\r\n        EnterCriticalSection(&CritSection);\r\n        SleepConditionVariableCS(&ConditionVar, &CritSection, INFINITE/*100*/);\r\n        LeaveCriticalSection(&CritSection);\r\n\r\n\r\n\r\n\r\n        WaitForSingleObject(hThread, 10000);\r\n\r\n        CloseHandle(hThread);\r\n    }\r\n    //FAIL();\r\n#endif\r\n}\r\n\r\n"
	},
	{
		"testcasename": "concept",
		"testname": "i_have_32threads_cpu",
		"filepath": "tests/google_tests/cplusplus_test.cpp",
		"filename": "cplusplus_test.cpp",
		"body": "TEST(concept, i_have_32threads_cpu) {\r\n    std::atomic<bool> atomicvalue{ true };\r\n    if (atomicvalue) {\r\n        // FAIL();\r\n    }\r\n}\r\n"
	},
	{
		"testcasename": "concept",
		"testname": "add_consume_test",
		"filepath": "tests/google_tests/cplusplus_test.cpp",
		"filename": "cplusplus_test.cpp",
		"body": "TEST(concept, add_consume_test) {\r\n\r\n    // Let's measure time for two threads to communicate via a work queue\r\n\r\n\r\n    using newtype = unsigned int;\r\n\r\n    static int work_node_max = ARM ? 2050 * 2 : 1800 * 2;\r\n\r\n    static std::atomic<bool> wow2{ false };\r\n\r\n    static constexpr int SET_VALUE = 11;\r\n\r\n    newtype loopCount = work_node_max;// ARM ? 1000 * 70 : 1000 * 100;\r\n    newtype outLoop = ARM ? 1000 * 1 : 100 * 1;\r\n    static int total_i = 0;\r\n    total_i = 0;\r\n\r\n    static long long total_nano_sec = 0;\r\n    total_nano_sec = 0;\r\n\r\n    static long long total_calc = 0;\r\n    total_calc = 0;\r\n\r\n\r\n\r\n    //#pragma pack(8)\r\n    struct WorkItem {\r\n        std::atomic<WorkItem*> next{ nullptr };\r\n\r\n        // incremental flag to deal with cache\r\n        uint64_t serverRevision = 0;\r\n        uint64_t clientRevision = 0;\r\n\r\n        //uint64_t serverLocalId = 10;\r\n\r\n        //uint32_t sessionIndex = 0;\r\n        std::atomic<int> finished{ -1 };\r\n\r\n        /*\r\n        int value16;\r\n        int value17;\r\n        int value18;\r\n        int value19;\r\n        int value20;\r\n        int value21;\r\n        int value22;\r\n        int value23;\r\n        int value24;\r\n        int value25;\r\n        int value26;\r\n        int value27;\r\n        int value28;\r\n        int value29;\r\n        int value30;\r\n        int value31;\r\n        */\r\n\r\n\r\n        char value0;\r\n        char value1;\r\n        char value2;\r\n        char value3;\r\n        char value4;\r\n        char value5;\r\n        char value6;\r\n        char value7;\r\n        char value8;\r\n        char value9;\r\n        char value10;\r\n        char value11;\r\n        char value12;\r\n        char value13;\r\n        char value14;\r\n        char value15;\r\n\r\n\r\n        /*\r\n        int val2[8];\r\n        int val32[16];\r\n        int val42[16];\r\n        int val52[16];\r\n        uint16_t arr[16];\r\n        uint16_t arr0[16];\r\n        uint16_t arr1[16];\r\n        uint16_t arr2[16];\r\n*/\r\n    };\r\n\r\n\r\n\r\n    auto *cacheVec = new std::vector<WorkItem *>{};\r\n    {\r\n        for (int i = 0; i < work_node_max; i++) {\r\n            auto *newLastItem = new WorkItem();\r\n            cacheVec->push_back(newLastItem);\r\n        }\r\n    }\r\n\r\n\r\n\r\n    for (int ntry = 0; ntry < outLoop; ntry++) {\r\n\r\n        for (int jj = 0; jj < 1; jj++) {\r\n\r\n            for (int k = 0; k < cacheVec->size(); k++) {\r\n                auto &&aa = cacheVec->at(k);\r\n                //aa->sessionIndex = 3;\r\n\r\n                const int gk = -3 - jj;\r\n                aa->value15 = gk + 8;\r\n                aa->value0 = gk + 8;\r\n                aa->value1 = gk + 8;\r\n                aa->value2 = gk + 8;\r\n                aa->value3 = gk + 8;\r\n                aa->value4 = gk + 8;\r\n                aa->value5 = gk + 8;\r\n                aa->value6 = gk + 8;\r\n                aa->value7 = gk + 8;\r\n                aa->value8 = gk + 8;\r\n                aa->value9 = gk + 8;\r\n                aa->value10 = gk + 8;\r\n                aa->value11 = gk + 8;\r\n                aa->value12 = gk + 8;\r\n                aa->value13 = gk + 8;\r\n                aa->value14 = gk + 8;\r\n            };\r\n        }\r\n\r\n\r\n        WorkItem *firstItem = new WorkItem{};\r\n\r\n\r\n        std::mt19937 get_rand_mt;\r\n        //std::shuffle(cacheVec->begin(), cacheVec->end(), get_rand_mt);\r\n\r\n        std::atomic_thread_fence(std::memory_order_release);\r\n\r\n        auto add_thread = std::thread(\r\n            [](int index, WorkItem *firstItem, std::vector<WorkItem *>* cacheVec) {\r\n\r\n\r\n            WorkItem *currentItem = firstItem;\r\n\r\n            // Add work queues\r\n            for (auto&&item : *cacheVec) {\r\n                item->next.store(nullptr, std::memory_order_relaxed);\r\n                item->finished.store(-1, std::memory_order_relaxed);\r\n                item->serverRevision++;\r\n\r\n                std::atomic_thread_fence(std::memory_order_release);\r\n\r\n                currentItem->next.store(item, std::memory_order_relaxed);\r\n\r\n                std::atomic_thread_fence(std::memory_order_release);\r\n\r\n\r\n\r\n                constexpr int k = 3;\r\n                item->value0 = k + 8;\r\n                item->value1 = k + 8;\r\n                item->value2 = k + 8;\r\n                item->value3 = k + 8;\r\n                item->value4 = k + 8;\r\n                item->value5 = k + 8;\r\n                item->value6 = k + 8;\r\n                item->value7 = k + 8;\r\n                std::atomic_thread_fence(std::memory_order_release);\r\n                item->value8 = k + 8;\r\n                item->value9 = k + 8;\r\n                item->value10 = k + 8;\r\n                item->value11 = k + 8;\r\n                item->value12 = k + 8;\r\n                item->value13 = k + 8;\r\n                item->value14 = k + 8;\r\n\r\n                std::atomic_thread_fence(std::memory_order_release);\r\n\r\n                item->value15 = k + 8;\r\n\r\n                currentItem = item;\r\n            }\r\n            currentItem->finished.store(15, std::memory_order_relaxed);\r\n\r\n            std::atomic_thread_fence(std::memory_order_release);\r\n\r\n\r\n\r\n        }, 3, firstItem, cacheVec);\r\n\r\n        // add_thread.join();\r\n\r\n        // std::this_thread::sleep_for(std::chrono::milliseconds{ 1 });\r\n\r\n\r\n        auto consume_thread = std::thread([](int index, WorkItem *firstItem) {\r\n\r\n            auto start = std::chrono::high_resolution_clock::now();\r\n\r\n            int i_sum = 0;\r\n            auto *targetItem = firstItem;\r\n            int i = 0;\r\n            while (true) {\r\n                std::atomic_thread_fence(std::memory_order_acquire);\r\n\r\n                auto *tempNext = targetItem->next.load(std::memory_order_relaxed);\r\n                if (tempNext != nullptr\r\n                    //&& tempNext->clientRevision+1 == tempNext->serverRevision\r\n                    ) {\r\n\r\n                    if (tempNext->clientRevision + 1 != tempNext->serverRevision)\r\n                    {\r\n                        FAIL();\r\n                    }\r\n\r\n                    i_sum++;\r\n                    targetItem = tempNext;\r\n                    targetItem->clientRevision++;\r\n\r\n\r\n                    if (targetItem->value15 == SET_VALUE) {\r\n\r\n                        std::atomic_thread_fence(std::memory_order_acquire);\r\n\r\n                        if (\r\n                            targetItem->value0 == SET_VALUE\r\n                            && targetItem->value5 == SET_VALUE\r\n                            && targetItem->value6 == SET_VALUE\r\n                            && targetItem->value7 == SET_VALUE\r\n                            && targetItem->value8 == SET_VALUE\r\n                            && targetItem->value9 == SET_VALUE\r\n                            && targetItem->value1 == SET_VALUE\r\n                            && targetItem->value2 == SET_VALUE\r\n                            && targetItem->value3 == SET_VALUE\r\n                            && targetItem->value4 == SET_VALUE\r\n                            && targetItem->value10 == SET_VALUE\r\n                            && targetItem->value11 == SET_VALUE\r\n                            && targetItem->value12 == SET_VALUE\r\n                            && targetItem->value13 == SET_VALUE\r\n                            && targetItem->value14 == SET_VALUE\r\n                            /*\r\n                            && targetItem->value16 == SET_VALUE\r\n                            && targetItem->value17 == SET_VALUE\r\n                            && targetItem->value18 == SET_VALUE\r\n                            && targetItem->value19 == SET_VALUE\r\n                            && targetItem->value20 == SET_VALUE\r\n                            && targetItem->value21 == SET_VALUE\r\n                            && targetItem->value22 == SET_VALUE\r\n                            && targetItem->value23 == SET_VALUE\r\n                            && targetItem->value24 == SET_VALUE\r\n                            && targetItem->value25 == SET_VALUE\r\n                            && targetItem->value26 == SET_VALUE\r\n                            && targetItem->value27 == SET_VALUE\r\n                            && targetItem->value28 == SET_VALUE\r\n                            && targetItem->value29 == SET_VALUE\r\n                            && targetItem->value30 == SET_VALUE\r\n                            */\r\n\r\n                            )\r\n                        {\r\n\r\n                        }\r\n                        else {\r\n                            //FAIL();\r\n                        }\r\n                    }\r\n\r\n\r\n                    if (targetItem->value15 != SET_VALUE) {\r\n                        i++;\r\n\r\n                        {\r\n                            int try_n = 0;\r\n                            volatile int vi = 0;\r\n                            while (true) {\r\n                                vi++;\r\n\r\n                                if (ARM) {\r\n                                    wow2.store(!wow2.load(), std::memory_order_relaxed);\r\n                                }\r\n                                else {\r\n                                    do_pause_or_nothing();\r\n                                }\r\n\r\n                                if (SET_VALUE == targetItem->value15) {\r\n                                    i--;\r\n                                    break;\r\n                                }\r\n\r\n                                try_n++;\r\n                                if (try_n > 300) {\r\n                                    int try_n2 = 0;\r\n                                    while (true) {\r\n                                        std::this_thread::sleep_for(\r\n                                            std::chrono::milliseconds{ 0 }\r\n                                        );\r\n                                        if (SET_VALUE == targetItem->value15) {\r\n                                            i--;\r\n                                            break;\r\n                                        }\r\n\r\n                                        try_n2++;\r\n\r\n                                        if (try_n2 > 9) {\r\n                                            while (true) {\r\n                                                if (SET_VALUE == targetItem->value15) {\r\n                                                    i--;\r\n                                                    break;\r\n                                                }\r\n                                                std::this_thread::sleep_for(std::chrono::milliseconds{ 1 });\r\n                                            }\r\n\r\n                                            break;\r\n                                        }\r\n                                    }\r\n\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    if (targetItem->finished.load(std::memory_order_relaxed) == 15) {\r\n                        break;\r\n                    }\r\n                    else {\r\n                        wow2.store(!wow2.load(), std::memory_order_relaxed);\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            total_i += i;\r\n\r\n\r\n\r\n            auto elapsed = std::chrono::high_resolution_clock::now() - start;\r\n            auto nanoseconds = std::chrono::duration_cast<std::chrono::nanoseconds>(elapsed).count();\r\n            total_nano_sec += nanoseconds;\r\n\r\n            total_calc += i_sum;\r\n\r\n        }, 3, firstItem);\r\n\r\n        add_thread.join();\r\n        consume_thread.join();\r\n\r\n    }\r\n\r\n    // dispose\r\n    for (auto&&item : *cacheVec) {\r\n        delete item;\r\n    }\r\n    delete cacheVec;\r\n\r\n    auto one_op_nanosec = total_nano_sec / static_cast<float>(loopCount*outLoop * 16);\r\n\r\n    EXPECT_EQ(total_i, 0);\r\n    EXPECT_EQ(total_calc, outLoop*loopCount);\r\n\r\n    if (speed_test) {\r\n        EXPECT_LT(one_op_nanosec, ARM ? 35 : 1);\r\n    }\r\n\r\n\r\n    std::cout << one_op_nanosec << \": nanosec-----------------------------\";\r\n\r\n    if (managed_cmake_test == false) {\r\n        EXPECT_EQ(\"\", \"Fail to see log\");\r\n    }\r\n}\r\n\r\n"
	},
	{
		"testcasename": "concept",
		"testname": "unordered_map_test",
		"filepath": "tests/google_tests/cplusplus_test.cpp",
		"filename": "cplusplus_test.cpp",
		"body": "TEST(concept, unordered_map_test) {\r\n\r\n    auto map = new std::unordered_map<int, int>();\r\n    //map->reserve(1000 * 1000);\r\n    int loopCount = 1000 * 10;\r\n    for (int i = 0; i < loopCount; i++) {\r\n        map->insert(std::make_pair(i, i + 1));\r\n    }\r\n\r\n    auto start = std::chrono::high_resolution_clock::now();\r\n\r\n    int result = 0;\r\n    for (int i = 0; i < loopCount; i++) {\r\n        result = map->at(i);\r\n    }\r\n\r\n    auto elapsed = std::chrono::high_resolution_clock::now() - start;\r\n\r\n    auto nanoseconds = std::chrono::duration_cast<std::chrono::nanoseconds>(elapsed).count();\r\n\r\n    auto one_op_nanosec = nanoseconds / static_cast<float>(loopCount);\r\n\r\n    if (speed_test) {\r\n        EXPECT_LT(one_op_nanosec, 100);\r\n        printf(\"%f\", one_op_nanosec);\r\n    }\r\n    EXPECT_EQ(result, loopCount);\r\n\r\n}\r\n\r\n"
	},
	{
		"testcasename": "ParserTest_",
		"testname": "JsonParseTest",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(ParserTest_, JsonParseTest) {\r\n\r\n    {\r\n        // preserve spaces and line-breaks\r\n        char *text = const_cast<char *>(u8R\"(\r\n{\"jsonrpc\":\"2.0\",\"id\":0,\"method\":\"initialize\",\"params\":{\"processId\":28196,\"rootPath\":null,\"rootUri\":null,\"capabilities\":{\"workspace\":{\"applyEdit\":true,\"workspaceEdit\":{\"documentChanges\":true},\"didChangeConfiguration\":{\"dynamicRegistration\":true},\"didChangeWatchedFiles\":{\"dynamicRegistration\":true},\"symbol\":{\"dynamicRegistration\":true,\"symbolKind\":{\"valueSet\":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]}},\"executeCommand\":{\"dynamicRegistration\":true},\"configuration\":true,\"workspaceFolders\":true},\"textDocument\":{\"publishDiagnostics\":{\"relatedInformation\":true},\"synchronization\":{\"dynamicRegistration\":true,\"willSave\":true,\"willSaveWaitUntil\":true,\"didSave\":true},\"completion\":{\"dynamicRegistration\":true,\"contextSupport\":true,\"completionItem\":{\"snippetSupport\":true,\"commitCharactersSupport\":true,\"documentationFormat\":[\"markdown\",\"plaintext\"],\"deprecatedSupport\":true},\"completionItemKind\":{\"valueSet\":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]}},\"hover\":{\"dynamicRegistration\":true,\"contentFormat\":[\"markdown\",\"plaintext\"]},\"signatureHelp\":{\"dynamicRegistration\":true,\"signatureInformation\":{\"documentationFormat\":[\"markdown\",\"plaintext\"]}},\"definition\":{\"dynamicRegistration\":true},\"references\":{\"dynamicRegistration\":true},\"documentHighlight\":{\"dynamicRegistration\":true},\"documentSymbol\":{\"dynamicRegistration\":true,\"symbolKind\":{\"valueSet\":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]}},\"codeAction\":{\"dynamicRegistration\":true},\"codeLens\":{\"dynamicRegistration\":true},\"formatting\":{\"dynamicRegistration\":true},\"rangeFormatting\":{\"dynamicRegistration\":true},\"onTypeFormatting\":{\"dynamicRegistration\":true},\"rename\":{\"dynamicRegistration\":true},\"documentLink\":{\"dynamicRegistration\":true},\"typeDefinition\":{\"dynamicRegistration\":true},\"implementation\":{\"dynamicRegistration\":true},\"colorProvider\":{\"dynamicRegistration\":true}}},\"trace\":\"off\",\"workspaceFolders\":null}}\r\n)\");\r\n        testJson(text);\r\n    }\r\n\r\n    {\r\n        char *text = const_cast<char *>(u8R\"( {\"jsonrpc\":\"2.0\", \"method\" : \"initialized\r\n)\");\r\n        auto *document = Alloc::newDocument(DocumentType::JsonDocument, nullptr);\r\n        DocumentUtils::parseText(document, text, strlen(text));\r\n\r\n\r\n        EXPECT_EQ(document->context->syntaxErrorInfo.hasError, true);\r\n        EXPECT_EQ(static_cast<int>(document->context->syntaxErrorInfo.errorItem.errorCode), static_cast<int>(ErrorCode::missing_closing_quote));\r\n        EXPECT_EQ(std::string{ document->context->syntaxErrorInfo.errorItem.reason }, std::string{ \"missing closing quote\" });\r\n    }\r\n\r\n\r\n\r\n    {\r\n        char *text = const_cast<char *>(u8R\"( {\"jsonrpc\":\"2.0\", \"method\" : \"\\\"initialized\\\"\"})\");\r\n        auto *document = Alloc::newDocument(DocumentType::JsonDocument, nullptr);\r\n        DocumentUtils::parseText(document, text, strlen(text));\r\n        auto *rootJson = Cast::downcast<JsonObjectStruct*>(document->firstRootNode);\r\n        EXPECT_NE(rootJson, nullptr);\r\n\r\n        DocumentUtils::generateHashTables(document);\r\n        auto *item = (NodeBase*)rootJson->hashMap->get2(\"method\");\r\n\r\n        EXPECT_NE(item, nullptr);\r\n        EXPECT_EQ(item->vtable, VTables::StringLiteralVTable);\r\n\r\n        auto *strNode = Cast::downcast<StringLiteralNodeStruct*>(item);\r\n        EXPECT_EQ( strNode->strLength, 13);\r\n        EXPECT_EQ( strNode->textLength, 17);\r\n        EXPECT_EQ(std::string{ strNode->str }, std::string{ \"\\\"initialized\\\"\" });\r\n        //EXPECT_EQ(std::string{ strNode->text }, std::string{ \"\\\\\\\"initialized\\\\\\\"\" });\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /*\r\n    {\r\n        char *text = const_cast<char *>(u8R\"({\"jsonrpc\":\"2.0\", \"method\" : \"textDocument/didOpen\", \"params\" : {\"textDocument\":{\"uri\":\"file:///c%3A/Users/Desktop/AAA.txt\", \"languageId\" : \"plaintext\", \"version\" : 1, \"text\" : \"AAA\\r\\n\\r\\n\\r\\n\\r\\nBBB\\r\\nCCC\\r\\nAAA\\r\\nBBB\"}}})\");\r\n        testJson(text);\r\n    }\r\n    */\r\n\r\n\r\n    // follow indent rule\r\n    {\r\n        auto text = const_cast<char *>(u8R\"(\r\n{\r\n        \"aowowo\" :    21249,\r\n\"jio fw\" : null,\r\n            \"text\" : \"日本語\"\r\n            \"ijofw\": [2134\r\n                      ,\r\n                            \"test\", true\r\n                        null,\r\n                        {\"君はどうなんだろう\": [true]}\r\n            ]\r\n\r\n})\");\r\n        testJson(text);\r\n    }\r\n\r\n\r\n    {\r\n\r\n        auto text = const_cast<char *>(u8R\"({\"aowfowo\" : \"😀😁😂ネコの顔文字と💘❤💓\", \"jiofw\": false})\");\r\n        testJson(text);\r\n    }\r\n\r\n\r\n    testJson(\"{}\");    // empty json object\r\n    testJson(\"[]\");    // empty json array\r\n    testJson(\"[298341,12432134, true, false, \\\"fwo\\\", null]\");\r\n\r\n    // comma is not needed after break line\r\n    {\r\n        auto text = const_cast<char*>(u8R\"(\r\n    [\r\n        \"aowowo\"\r\n        null\r\n        \"日本語\"\r\n        {\"君はどうなんだろう\": [true]}\r\n\r\n    ])\");\r\n        testJson(text);\r\n    }\r\n\r\n    testJson(u8R\"({\"empty_array\" : [\r\n            421,true, \"ijofwe\", null,false]})\");\r\n\r\n    {\r\n        // nested json object\r\n        auto text = const_cast<char *>(u8R\"({\"jfoiw\": { \"fjioew\"  :   { \"jfiow\": true } \r\n\r\n        } \r\n\r\n            })\");\r\n        testJson(text);\r\n    }\r\n\r\n    {\r\n        // last comma is allowed\r\n        auto text = const_cast<char *>(u8R\"({\"jfoiw\": true\r\n\r\n    , \r\n}\r\n)\");\r\n        testJson(text);\r\n    }\r\n}\r\n\r\nstatic void testJson(const char* codeText) {\r\n    auto *document = Alloc::newDocument(DocumentType::JsonDocument, nullptr);\r\n    DocumentUtils::parseText(document, codeText, strlen(codeText));\r\n    //char *typeText = DocumentUtils::getTypeTextFromTree(document);\r\n    //    if (typeText != nullptr) {\r\n            //EXPECT_EQ(std::string{ typeText }, std::string{ \"fjow\" });\r\n        //}\r\n\r\n    char *treeText = DocumentUtils::getTextFromTree(document);\r\n    DocumentUtils::generateHashTables(document);\r\n    /*\r\n    auto *jsonObject = DocumentUtils::generateHashTables(document);\r\n    if (jsonObject) {\r\n        auto *item = jsonObject->hashMap->get2(\"aowfowo\");\r\n        printf(\"item - %d\", item);\r\n    }\r\n    */\r\n\r\n    //if (treeText != nullptr) {\r\n        //Allocator::deleteDocument(document);\r\n        // EXPECT_EQ(std::string(treeText), \"\\n{b:18}\\n\");\r\n    EXPECT_EQ(std::string{ treeText }, std::string{ codeText });\r\n    //}\r\n\r\n    Alloc::deleteDocument(document);\r\n}\r\n\r\n\r\n"
	},
	{
		"testcasename": "ParserTest_",
		"testname": "char_iteration",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(ParserTest_, char_iteration) {\r\n\r\n    std::string wstr{ u8\"auto * 😂日本語たち=10234;\" };\r\n    std::string wstr2{ \"class TestClass{ }\" };\r\n    //int alen = wstr.length();\r\n    auto chs = std::vector<char>{};\r\n\r\n    //chs.push_back(0xEF);\r\n    //chs.push_back(0xBB);\r\n    //chs.push_back(0xBF);\r\n\r\n    //std::cout << \"\\n[\" << wstr.length() << \"\\n\";\r\n\r\n    char *text = const_cast<char *>(wstr.c_str());\r\n    for (int i = 0; true; i++) {\r\n        auto ch = text[i];\r\n        if (ch == '\\0') {\r\n            //printf(\"TestImpl : %d, %d\", i, alen);\r\n            break;\r\n        }\r\n\r\n        if ((ch & 0x80) != 0x80) {\r\n            // if (ch >> 7 == 0) {\r\n            // if (ch  <= 0x7F) {\r\n\r\n            //printf(\"ch = %c\\n\", ch);\r\n\r\n        }\r\n        else {\r\n            // printf(\"jap ch = %c\\n\", ch);\r\n            chs.push_back(ch);\r\n        }\r\n    }\r\n\r\n    chs.push_back('\\0');\r\n    std::string parsed_text{ &chs[0] };\r\n\r\n    EXPECT_EQ(chs.size(), 20);\r\n\r\n    if (ARM) {\r\n        // This might cause crash on old android devices\r\n        //EXPECT_EQ(parsed_text, \"😂日本語たち\");\r\n    }\r\n\r\n    // printf(\"japanese text = %s, \", a);\r\n}\r\n\r\n"
	},
	{
		"testcasename": "ParserTest_",
		"testname": "escapeJsonUtf16",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(ParserTest_, escapeJsonUtf16) {\r\n    {\r\n        const char* str = u8\"\\\\u0061\"; // a\r\n        unsigned char ch1, ch2, ch3, ch4;\r\n        int consumed;\r\n        int utf16length = ParseUtil::parseJsonUtf16Sequense(str, strlen(str), 0, &consumed, &ch1, &ch2, &ch3, &ch4);\r\n        EXPECT_EQ(utf16length, 1);\r\n        EXPECT_EQ(ch1, 0x61);\r\n    }\r\n\r\n    {\r\n        //%C3%9F\r\n        const char* str = u8\"\\\\u00df\"; // ß\r\n        unsigned char ch1=0, ch2=0, ch3=0, ch4=0;\r\n        int consumed;\r\n\r\n        int utf16length = ParseUtil::parseJsonUtf16Sequense(str, strlen(str), 0, &consumed, &ch1, &ch2, &ch3, &ch4);\r\n\r\n        EXPECT_EQ(utf16length, 2);\r\n        EXPECT_EQ(ch1, 0xC3);\r\n        EXPECT_EQ(ch2, 0x9F);\r\n    }\r\n\r\n    {\r\n        //虎\r\n        //u864e\r\n        //\\xE8\\x99\\x8E\\xE3\\x81\\xAE\r\n        const char str[] = u8\"\\\\u864e\";\r\n        unsigned char ch1, ch2, ch3, ch4;\r\n        int consumed;\r\n        int utf16length = ParseUtil::parseJsonUtf16Sequense(str, strlen(str), 0, &consumed, &ch1, &ch2, &ch3, &ch4);\r\n        EXPECT_EQ(utf16length, 3);\r\n        EXPECT_EQ(ch1, 0xE8);\r\n        EXPECT_EQ(ch2, 0x99);\r\n        EXPECT_EQ(ch3, 0x8E);\r\n    }\r\n    \r\n    {\r\n\r\n        // 𠏹\r\n        // {\\\"fwe\\\": \\\"\\uD840\\uDFF9\\\"}\r\n        // &#x203F9;\r\n        // &#132089;\r\n        // URL - encoded UTF8 % F0 % A0 % 8F % B9\r\n        const char str[] = u8\"\\\\uD840\\\\uDFF9\";\r\n        constexpr unsigned char rawStr[] = u8\"𠏹\";\r\n        unsigned char ch1, ch2, ch3, ch4;\r\n        int consumed;\r\n        int utf16length = ParseUtil::parseJsonUtf16Sequense(str, strlen(str), 0, &consumed, &ch1, &ch2, &ch3, &ch4);\r\n        EXPECT_EQ(utf16length, 4);\r\n        EXPECT_EQ(ch1, 0xF0);\r\n        EXPECT_EQ(ch2, 0xA0);\r\n        EXPECT_EQ(ch3, 0x8F);\r\n        EXPECT_EQ(ch4, 0xB9);\r\n\r\n        EXPECT_EQ(ch1, rawStr[0]);\r\n        EXPECT_EQ(ch2, rawStr[1]);\r\n        EXPECT_EQ(ch3, rawStr[2]);\r\n        EXPECT_EQ(ch4, rawStr[3]);\r\n\r\n    }\r\n\r\n    int ch = (int)219;\r\n    EXPECT_EQ((ch >> 2) == 0x36, true);\r\n}\r\n\r\n"
	},
	{
		"testcasename": "ParserTest_",
		"testname": "utf16Length",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(ParserTest_, utf16Length) {\r\n\r\n    // Table 3-8.  Use of U+FFFD in UTF-8 Conversion\r\n    // http://www.unicode.org/versions/Unicode6.1.0/ch03.pdf\r\n\r\n    {\r\n        const char *str = u8\"👨‍👩‍👧\";\r\n        int utf16length = ParseUtil::utf16_length(str, strlen(str));\r\n        EXPECT_EQ(utf16length, 8);\r\n    }\r\n\r\n    {\r\n        const char *str = u8\"😂abcd\";\r\n        int utf16length = ParseUtil::utf16_length(str, 4); // only for the first emoji\r\n        EXPECT_EQ(utf16length, 2);\r\n    }\r\n\r\n    {\r\n        const char *str = u8\"nanimo-*\";\r\n        auto utf16length = ParseUtil::utf16_length(str, strlen(str));\r\n        EXPECT_EQ(utf16length, 8);\r\n    }\r\n\r\n    {\r\n        const char *str = u8\"a𐐀b\";\r\n        auto utf16length = ParseUtil::utf16_length(str, strlen(str));\r\n        EXPECT_EQ(utf16length, 4);\r\n    }\r\n\r\n    {\r\n        const char *str = u8\"\\r\\n\\n\"; // line break\r\n        auto utf16length = ParseUtil::utf16_length(str, strlen(str));\r\n        EXPECT_EQ(utf16length, 3);\r\n    }\r\n\r\n    {\r\n        const char *str = u8\" \"; // 1 space\r\n        auto utf16length = ParseUtil::utf16_length(str, strlen(str));\r\n        EXPECT_EQ(utf16length, 1);\r\n    }\r\n\r\n    {\r\n        const char *str = u8\"\"; // empty string\r\n        auto utf16length = ParseUtil::utf16_length(str, strlen(str));\r\n        EXPECT_EQ(utf16length, 0);\r\n    }\r\n\r\n    {\r\n        const char *str = u8\"Hasta el próximo miércoles\"; // spanish\r\n        auto utf16length = ParseUtil::utf16_length(str, strlen(str));\r\n        EXPECT_EQ(utf16length, 26);\r\n    }\r\n\r\n    {\r\n        const char *str = u8\"de 13.0 と Emoji 13.0 に準拠した 😀😁😂などの色々な表情の顔文字や 👿悪魔 👹鬼 👺天狗 👽エイリアン 👻おばけ 😺ネコの顔文字と💘❤💓💔💕💖ハ\";\r\n        int utf16length = ParseUtil::utf16_length(str, strlen(str));\r\n        EXPECT_EQ(utf16length, 96);\r\n    }\r\n\r\n    {\r\n        const char *str = u8\"我喜欢吃水果。Wǒ xǐhuan chī shuǐguǒ．私は果物が好きです。\";\r\n        int utf16length = ParseUtil::utf16_length(str, strlen(str));\r\n        EXPECT_EQ(utf16length, 39);\r\n    }\r\n\r\n    {\r\n        const char *str = u8\"안녕하세요\";\r\n        int utf16length = ParseUtil::utf16_length(str, strlen(str));\r\n        EXPECT_EQ(utf16length, 5);\r\n    }\r\n\r\n\r\n}\r\n\r\n"
	},
	{
		"testcasename": "parser_test",
		"testname": "utf8ToCodePoint",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(parser_test, utf8ToCodePoint) {\r\n\r\n    // Table 3-8.  Use of U+FFFD in UTF-8 Conversion\r\n     // http://www.unicode.org/versions/Unicode6.1.0/ch03.pdf\r\n    //char *str = u8\"😂日本語たち\";// u8\"nanimo-*\";// u8\"あいえおkん\";// \"👨‍👩‍👧\";\r\n    char *str = u8\"👨‍👩‍👧\";\r\n    unsigned int code_point, len, cursor, cursor_before;\r\n\r\n    len = strlen(str);\r\n    cursor = 0;\r\n\r\n    while (cursor < len) {\r\n        cursor_before = cursor;\r\n        code_point = utf8_get_next_char_or_ufffd((const unsigned char*)str, len, &cursor);\r\n        printf(\"U+%X カーソル:%d\\n\", ConvChU32ToU16(code_point), cursor_before);\r\n    }\r\n\r\n    //EXPECT_LT(one_op_nanosec, 40000);\r\n    //EXPECT_EQ(count, loopCount - 1);\r\n    //EXPECT_EQ(ch, ' ');\r\n\r\n}\r\n\r\n"
	},
	{
		"testcasename": "ParserTest_",
		"testname": "JustScanLetters",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(ParserTest_, JustScanLetters) {\r\n\r\n    auto start = std::chrono::high_resolution_clock::now().time_since_epoch();\r\n    uint64_t loopCount = 100 * 1000LLU;\r\n\r\n    std::string text = u8R\"(\r\nclass TestCl😂日本語10234ass {\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\nclass a {\r\n\r\n}\r\nclass agiplkmp {\r\n\r\n}\r\n\r\nclass jips {\r\n\r\n}\r\n\r\n\r\n\r\n\r\n  )\";\r\n\r\n    unsigned long long count = 0;\r\n    const char *chars = text.c_str();\r\n    char ch = 'a';\r\n    for (unsigned long long i = 0; i < loopCount; i++) {\r\n        if (i > 5) {\r\n            for (int_fast32_t k = 0; k < text.size(); k++) {\r\n                ch = chars[k];\r\n                if (ch == ' ') {\r\n                    count = i;\r\n                }\r\n                else if (ch == 'a') {\r\n                    count = i;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    auto elapsed = std::chrono::high_resolution_clock::now().time_since_epoch() - start;\r\n    auto nanoseconds = std::chrono::duration_cast<std::chrono::nanoseconds>(elapsed).count();\r\n    auto one_op_nanosec = nanoseconds / static_cast<double>(loopCount);\r\n\r\n    EXPECT_LT(one_op_nanosec, 40000);\r\n    EXPECT_EQ(count, loopCount - 1);\r\n    EXPECT_EQ(ch, ' ');\r\n\r\n}\r\n\r\n"
	},
	{
		"testcasename": "parser_test",
		"testname": "ParserStream",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(parser_test, ParserStream) {\r\n    FILE *fp;\r\n    size_t rsize;\r\n    int ret;\r\n    static constexpr int BUFFER_SIZE = 10240;\r\n    char buff[BUFFER_SIZE];\r\n\r\n    fp = stdin;// fopen(\"ConsoleApplication2.pdb\", \"rb\");\r\n\r\n    if (fp == nullptr) {\r\n        printf(\"failed to open file:errno=%d\\n\", errno);\r\n        return;\r\n    }\r\n\r\n    int totalByteCount = 0;\r\n    while (true) {\r\n        rsize = fread(buff, 1, BUFFER_SIZE, fp);\r\n        if (rsize > 0) {\r\n            totalByteCount += rsize;\r\n\r\n            printf(\"rsize=%d\\n\", rsize);\r\n            continue;\r\n        }\r\n\r\n        break;\r\n    }\r\n\r\n    printf(\"total=%d\\n\", totalByteCount);\r\n\r\n\r\n    if (feof(fp) == 0) {\r\n        printf(\"failed to read file: errno=%d\\n\", errno);\r\n        fclose(fp);\r\n        return;\r\n    }\r\n\r\n    ret = fclose(fp);\r\n\r\n    if (ret != 0) {\r\n        printf(\"failed to close file: errno=%d\\n\", errno);\r\n        return;\r\n    }\r\n\r\n    //EXPECT_EQ(3, 4);\r\n\r\n}\r\n\r\n"
	},
	{
		"testcasename": "ParserTest_",
		"testname": "parser_benchmark",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(ParserTest_, parser_benchmark) {\r\n\r\n    auto start = std::chrono::high_resolution_clock::now().time_since_epoch();\r\n    uint64_t loopCount = 100 * 1000LLU;\r\n    //std::string text = \"   class           A   {    }   \";\r\n    std::string text = u8R\"(\r\nclass TestCl😂日本語10234ass {\r\n    fn func() {\r\n\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\nclass a {\r\n\r\n}\r\nclass agiplkmp {\r\n\r\n}\r\n\r\nclass jips {\r\n\r\n}\r\n\r\n \r\n\r\n\r\n  )\";\r\n\r\n    const char *chars = text.c_str();\r\n    int nodeCount = 0;\r\n    bool parsedGood = false;\r\n    for (unsigned long long i = 0; i < loopCount; i++) {\r\n        auto *document = Alloc::newDocument(DocumentType::CodeDocument, nullptr);\r\n        DocumentUtils::parseText(document, chars, text.size());\r\n        nodeCount = document->nodeCount;\r\n\r\n        parsedGood = !document->context->syntaxErrorInfo.hasError;\r\n\r\n        //console_log((\"i:\" + std::to_string()).c_str());\r\n        Alloc::deleteDocument(document);\r\n    }\r\n    \r\n    EXPECT_EQ(nodeCount, 4);\r\n    EXPECT_EQ(parsedGood, true);\r\n\r\n    auto elapsed = std::chrono::high_resolution_clock::now().time_since_epoch() - start;\r\n    auto nanoseconds = std::chrono::duration_cast<std::chrono::nanoseconds>(elapsed).count();\r\n    auto one_op_nanosec = nanoseconds / static_cast<double>(loopCount);\r\n\r\n    EXPECT_LT(one_op_nanosec, 15000);\r\n    //EXPECT_LT(one_op_nanosec, 35000);\r\n    std::cout << \"one\" << one_op_nanosec;\r\n}\r\n\r\n"
	},
	{
		"testcasename": "ParserTest_",
		"testname": "aaHashMap",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(ParserTest_, aaHashMap) {\r\n    {\r\n        auto hashKey = VoidHashMap::calc_hash2(\"ak\", 10000);\r\n        auto hashKey2 = VoidHashMap::calc_hash2(\"ka\", 10000);\r\n        EXPECT_NE(hashKey, hashKey2);\r\n    }\r\n\r\n    {\r\n        auto hashKey = VoidHashMap::calc_hash2(\"N01\", 10000);\r\n        auto hashKey2 = VoidHashMap::calc_hash2(\"N01234C\", 10000);\r\n        EXPECT_NE(hashKey, hashKey2);\r\n    }\r\n\r\n    auto *context = (ParseContext *)malloc(sizeof(ParseContext));\r\n    context->memBuffer.init();\r\n\r\n    for (int i = 0; i < 100; i++) {\r\n\r\n        auto *hashMap = context->newMem<VoidHashMap>();\r\n        hashMap->init(&context->memBuffer);\r\n\r\n        auto *first = Cast::upcast(context->newMem<DocumentStruct>());\r\n        const char key[] = \"firstAA\";\r\n        hashMap->put2(key, Cast::upcast(context->newMem<DocumentStruct>()));\r\n        hashMap->put2(key, first); // replace\r\n\r\n        hashMap->put2(\"secondBB\", Cast::upcast(context->newMem<DocumentStruct>()));\r\n        hashMap->put2(\"jfiow\", Cast::upcast(context->newMem<DocumentStruct>()));\r\n        hashMap->put(\"jfiow\", sizeof(\"jfiow\") - 1, Cast::upcast(context->newMem<DocumentStruct>()));\r\n\r\n        auto *node = (NodeBase*)hashMap->get2(\"firstAA\");\r\n        EXPECT_EQ(node, first);\r\n\r\n        node = (NodeBase*)hashMap->get2(\"jfiow\");\r\n        EXPECT_EQ(node != nullptr, true);\r\n        {\r\n            auto *node2 = hashMap->get2(\"empty\");\r\n            EXPECT_EQ(node2, nullptr);\r\n        }\r\n\r\n        //free(hashMap);\r\n    }\r\n\r\n}\r\n\r\n"
	},
	{
		"testcasename": "ParserTest_",
		"testname": "charBuffer",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(ParserTest_, charBuffer) {\r\n    auto start = std::chrono::high_resolution_clock::now().time_since_epoch();\r\n    uint64_t loopCount = 100 * 1000LLU;\r\n\r\n    {\r\n        srand((unsigned int)time(nullptr));\r\n        for (int i = 0; i < 80 * 100; i++) {\r\n\r\n            auto *charBuffer3 = (MemBuffer*)malloc(sizeof(MemBuffer));\r\n            charBuffer3->init();\r\n            \r\n            unsigned int max = 1 + rand() % 10;\r\n            for (int j = 0; j < max; j++) {\r\n                unsigned int len = 1 + rand() % 100;\r\n\r\n                auto *chars = charBuffer3->newMem<S>(len);\r\n                chars->a = 5;\r\n\r\n                auto *chars2 = charBuffer3->newMem<S>(1);\r\n                chars2->a = 2;\r\n                EXPECT_EQ(chars->a, 5);\r\n                EXPECT_EQ(chars2->a, 2);\r\n\r\n                EXPECT_EQ(charBuffer3->currentBufferBlock, *((MemBufferBlock **)((st_byte*)chars2 - st_size_of(MemBufferBlock*))));\r\n\r\n                charBuffer3->tryDelete(chars);\r\n                charBuffer3->tryDelete(chars2);\r\n\r\n            }\r\n            charBuffer3->freeAll();\r\n            free(charBuffer3);\r\n        }\r\n\r\n    }\r\n\r\n    auto elapsed = std::chrono::high_resolution_clock::now().time_since_epoch() - start;\r\n    auto nanoseconds = std::chrono::duration_cast<std::chrono::nanoseconds>(elapsed).count();\r\n    auto one_op_nanosec = nanoseconds / static_cast<double>(loopCount);\r\n\r\n    EXPECT_LT(one_op_nanosec, 40000);\r\n}\r\n\r\n"
	},
	{
		"testcasename": "ParserTest_",
		"testname": "SameLength_01",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(ParserTest_, SameLength_01) {\r\n\r\n    // std::string text = \"   class           A   {    }   \";\r\n    //            $let *list: string* | null = null As string* | null\r\n    // \r\n    constexpr char text[] = R\"(\r\nclass fjawioejap\r\n{\r\n    fn funcB(int a, int *k = 31)\r\n    {\r\n        // comment\r\n        let a = 893214 // fawoiefjiawo\r\n        let *str = \"0jfoiwjoie\" // comment\r\n        int a = 123412\r\n        float test = 3214\r\n\r\n        $float f = 4503\r\n        ?let *f = null\r\n        $let g = true\r\n        a = 5\r\n        varibleAjoawiefjaipo\r\n        \r\n        \"jfoiwjeioaf\"\r\n            /*\r\n                /*fajowefjao \r\n                    /*\r\n                    */\r\n                */\r\n\r\n\r\n                 /*ajowiefaiow  \r\n                 joafwieコメント張りさん\r\n                 */\r\n            */\r\n\r\n            /*\r\n            comment here\r\n            */\r\n\r\n        let f = 3\r\n\r\n        \r\n        (true) + false + (\r\n            241\r\n        )\r\n        \r\n        funcA(true, \"jfiwo\")\r\n\r\n        return\r\n        return 3421\r\n    }\r\n}\r\n\r\nclass/**/A/**/{\r\n\r\n}\r\n)\";\r\n\r\n    testCodeEquality(text, sizeof(text)-1);\r\n}\r\n\r\n"
	},
	{
		"testcasename": "ParserTest_",
		"testname": "SameLength_Empty",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(ParserTest_, SameLength_Empty) {\r\n    testCodeEquality(\"\", 0);\r\n}\r\n\r\n"
	},
	{
		"testcasename": "ParserTest_",
		"testname": "SameLength_Empty2",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(ParserTest_, SameLength_Empty2) {\r\n    testCodeEquality(\" \\r\\n \\n\\n  \", 8);\r\n}\r\n\r\n"
	},
	{
		"testcasename": "ParserTest_",
		"testname": "failed_onAndroid9_sometimes",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(ParserTest_, failed_onAndroid9_sometimes) {\r\n    constexpr char source[] = R\"(\r\nfn funcA() {\r\n    int a = 243\r\n    i64 bigValue = 412431324L\r\n    return 214\r\n}\r\n\r\nfn main() {\r\n    string *ptr = \"ijfowjio\"\r\n    $string *ptr2 = ptr\r\n    int a = (243 + 432) - 3214\r\n    return a\r\n}\r\n)\";\r\n    for (int i = 0; i < 1000; i++) {\r\n        testCodeEquality(source, sizeof(source) - 1);\r\n    }\r\n}\r\n\r\n"
	},
	{
		"testcasename": "ParserTest_",
		"testname": "SameLength_blockComment",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(ParserTest_, SameLength_blockComment) {\r\n    const char text[] = \" /* \\r\\n /**/ bck\\r\\n\\n*/\";\r\n    testCodeEquality(text, sizeof(text) - 1);\r\n}\r\n\r\n"
	},
	{
		"testcasename": "ParserTest_",
		"testname": "parentheses",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(ParserTest_, parentheses) {\r\n    const char text[] = \"fn a() { (12) }\";\r\n    testCodeEquality(text, sizeof(text) - 1);\r\n}\r\n\r\n"
	},
	{
		"testcasename": "ParserTest_",
		"testname": "TestSeveralLines",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(ParserTest_, TestSeveralLines) {\r\n    \r\n    std::string text = \"class A \\r\\n // comment \\r\\n {}\";\r\n\r\n    const char* chars = text.c_str();\r\n    auto* document = Alloc::newDocument(DocumentType::CodeDocument, nullptr);\r\n    DocumentUtils::parseText(document, chars, text.size());\r\n\r\n    char* treeText = DocumentUtils::getTextFromTree(document);\r\n\r\n    EXPECT_EQ(treeText != nullptr, true);\r\n    EXPECT_EQ(std::string{ treeText }, std::string{ chars });\r\n    EXPECT_EQ(strlen(treeText), strlen(chars));\r\n\r\n    Alloc::deleteDocument(document);\r\n}\r\n\r\n"
	},
	{
		"testcasename": "ParserTest_",
		"testname": "TypeTreeTest",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(ParserTest_, TypeTreeTest) {\r\n    std::string text = u8R\"(\r\n        class TestCl😂日本語10234ass\r\n        {\r\n            fn func()\r\n            {\r\n                $let aw = 242\r\n                true\r\n                null\r\n                printf(214)\r\n            }\r\n        }\r\n)\";\r\n\r\n    const char* chars = text.c_str();\r\n    auto* document = Alloc::newDocument(DocumentType::CodeDocument, nullptr);\r\n    DocumentUtils::parseText(document, chars, text.size());\r\n\r\n    char* treeText = DocumentUtils::getTextFromTree(document);\r\n    char* typeTreeText = DocumentUtils::getTypeTextFromTree(document);\r\n\r\n    EXPECT_EQ(treeText != nullptr, true);\r\n    EXPECT_EQ(typeTreeText != nullptr, true);\r\n    EXPECT_EQ(std::string{ treeText }, std::string{ chars });\r\n    EXPECT_EQ(strlen(treeText), strlen(chars));\r\n\r\n\r\n    auto&& typeTree = u8R\"(<lineBreak>\r\n<Class>        class<Name> TestCl😂日本語10234ass<lineBreak>\r\n<Symbol>        {<lineBreak>\r\n<fn>            fn<Name> func<Symbol>(<Symbol>)<lineBreak>\r\n<body>            {<lineBreak>\r\n<Type>                $let<Name> aw<Symbol> =<number> 242<lineBreak>\r\n<bool>                true<lineBreak>\r\n<NULL>                null<lineBreak>\r\n<Variable>                printf<Symbol>(<FuncArgument><number>214<Symbol>)<lineBreak>\r\n<Symbol>            }<lineBreak>\r\n<Symbol>        }<lineBreak>\r\n<EndOfFile>)\";\r\n\r\n    EXPECT_EQ(std::string{ typeTreeText }, std::string{ typeTree });\r\n\r\n    Alloc::deleteDocument(document);\r\n}\r\n\r\n"
	},
	{
		"testcasename": "ParserTest_",
		"testname": "DepthTest",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(ParserTest_, DepthTest) {\r\n    std::string text = u8R\"(\r\nclass TestCl\r\n{\r\n    fn func()\r\n    {\r\n        let aw = 242\r\n    }\r\n}\r\n)\";\r\n\r\n    const char* chars = text.c_str();\r\n    auto* document = Alloc::newDocument(DocumentType::CodeDocument, nullptr);\r\n    DocumentUtils::parseText(document, chars, text.size());\r\n\r\n    auto* line = document->firstCodeLine;\r\n    int i = 0;\r\n    int depthList[] = {0,0,0,1,1,2,1,0,0};\r\n    while (line) {\r\n        EXPECT_EQ(line->depth, depthList[i]);\r\n        line = line->nextLine;\r\n        i++;\r\n    }\r\n\r\n    Alloc::deleteDocument(document);\r\n}\r\n\r\n"
	},
	{
		"testcasename": "ParserTest_",
		"testname": "NodeTypeEquality",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(ParserTest_, NodeTypeEquality) {\r\n    std::string text = u8R\"(\r\n\r\nclass A {\r\n    class B {\r\n        class TestCl😂日本語10234ass {\r\n\r\n            fn aFunc (\r\n                )\r\n            {\r\n                \r\n            }\r\n\r\n        }\r\n\r\n        class C { }\r\n    }\r\n}\r\n)\";\r\n\r\n    const char *chars = text.c_str();\r\n    auto *document = Alloc::newDocument(DocumentType::CodeDocument, nullptr);\r\n\r\n    DocumentUtils::parseText(document, chars, text.size());\r\n\r\n    char *treeText = DocumentUtils::getTextFromTree(document);\r\n    EXPECT_EQ(std::string(treeText), std::string(chars));\r\n    EXPECT_EQ(strlen(treeText), strlen(chars));\r\n\r\n    EXPECT_EQ(document->context->syntaxErrorInfo.hasError, false);\r\n\r\n\r\n    EXPECT_EQ(document->firstCodeLine->firstNode->vtable, VTables::LineBreakVTable);\r\n    EXPECT_EQ(document->firstCodeLine->nextLine->firstNode->vtable, VTables::LineBreakVTable);\r\n\r\n\r\n    Alloc::deleteDocument(document);\r\n}\r\n\r\n"
	},
	{
		"testcasename": "ParserTest_",
		"testname": "ErrorNodeTest",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(ParserTest_, ErrorNodeTest) {\r\n    return;\r\n    //std::string text = \"   class           A   {    }   \";\r\n    std::string text = u8R\"(\r\nclass A {\r\n\r\n    class B {\r\n        @hoge(akaw=3242, ajwe=2342)\r\n        class TestCl😂日本語10234ass {\r\n            \r\n        }\r\n\r\n        cmpl fn fawe() {\r\n\r\n        }\r\n    }\r\n}\r\nclass A {}\r\nclass A {}\r\nclass A {}\r\nclass BDD{}\r\n\r\n\r\n\r\n\r\nclass AABC  {  }\r\n)\";\r\n\r\n    const char *chars = text.c_str();\r\n    auto *document = Alloc::newDocument(DocumentType::CodeDocument, nullptr);\r\n\r\n    DocumentUtils::parseText(document, chars, text.size());\r\n\r\n    char *treeText = DocumentUtils::getTextFromTree(document);\r\n    EXPECT_EQ(std::string(treeText), std::string(chars));\r\n    EXPECT_EQ(strlen(treeText), strlen(chars));\r\n\r\n    Alloc::deleteDocument(document);\r\n\r\n}\r\n\r\n"
	},
	{
		"testcasename": "parser_test",
		"testname": "IndentTextTest",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(parser_test, IndentTextTest) {\r\n    std::string text = u8R\"(\r\nclass A {\r\n    class B {\r\n        class TestCl😂日本語10234ass {\r\n\r\n        }\r\n    }\r\n}\r\n)\";\r\n\r\n    std::string textWithIndent = u8R\"(\r\nclass A {\r\n    class B {\r\n        class TestCl😂日本語10234ass {\r\n            func(32423, ()=>{\r\n                var a = 2342;\r\n            }, 432);\r\n)\";\r\n\r\n    textWithIndent += \"            \";\r\n\r\n    textWithIndent += u8R\"(\r\n        }\r\n    }\r\n}\r\n)\";\r\n\r\n\r\n    const char *chars = text.c_str();\r\n    const char *indentChars = textWithIndent.c_str();\r\n    auto *document = Allocator::newDocument(DocumentType::CodeDocument, nullptr);\r\n\r\n    DocumentUtils::parseText(document, chars, text.size());\r\n\r\n    char *treeText = DocumentUtils::getTextFromTree(document);\r\n    EXPECT_EQ(std::string(treeText), std::string(indentChars));\r\n    EXPECT_EQ(strlen(treeText), strlen(chars));\r\n\r\n    Allocator::deleteDocument(document);\r\n\r\n}\r\n\r\n"
	},
	{
		"testcasename": "ParserTest_",
		"testname": "ParseUtil",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(ParserTest_, ParseUtil) {\r\n\r\n\r\n    EXPECT_EQ(true, ParseUtil::isIdentifierLetter('a'));\r\n\r\n    ParseUtil::letterCheck(&func);\r\n\r\n    // static inline int indexOfBreakOrEnd(const char *chars, int charsLength, int startIndex)\r\n    {\r\n        static constexpr char chars[] = \"class\\n A{}\";\r\n        EXPECT_EQ(5, ParseUtil::indexOfBreakOrEnd(chars, sizeof(chars)-1, 0));\r\n\r\n        static constexpr char chars2[] = \"class\\0 A{}\";\r\n        EXPECT_EQ(5, ParseUtil::indexOfBreakOrEnd(chars2, sizeof(chars2) - 1, 3));\r\n\r\n        static constexpr char chars3[] = \"class\\0 A{}\";\r\n        EXPECT_EQ(10, ParseUtil::indexOfBreakOrEnd(chars3, sizeof(chars3) - 1, 7));\r\n    }\r\n\r\n    {\r\n        static constexpr char chars[] = \"class\\n A{}\";\r\n        EXPECT_EQ(7, ParseUtil::indexOf(chars, sizeof(chars)-1, 0, 'A'));\r\n\r\n        static constexpr char chars2[] = \"class\\n A{}\";\r\n        EXPECT_EQ(-1, ParseUtil::indexOf(chars2, sizeof(chars2)-1, 0, 'G'));\r\n\r\n    }\r\n\r\n\r\n\r\n    {\r\n        static constexpr char chars[] = \"return    \\n\";\r\n        EXPECT_EQ(false, ParseUtil::hasCharBeforeLineBreak(chars, sizeof(chars)-1, 6));\r\n\r\n        static constexpr char chars2[] = \"return    a\\r\\n\";\r\n        EXPECT_EQ(true, ParseUtil::hasCharBeforeLineBreak(chars2, sizeof(chars2)-1, 6));\r\n\r\n    }\r\n\r\n    EXPECT_EQ(true, ParseUtil::isIdentifierLetter('a'));\r\n    EXPECT_EQ(true, ParseUtil::isIdentifierLetter(std::string{ u8\"😂\" }.c_str()[0]));\r\n    EXPECT_EQ(false, ParseUtil::isIdentifierLetter('\\n'));\r\n\r\n\r\n    static constexpr char chars[] = \"class A{}\";\r\n    EXPECT_EQ(0, ParseUtil::matchAt(chars, sizeof(chars) - 1, 0, \"class\"));\r\n\r\n    EXPECT_EQ(-1, ParseUtil::matchAt(\"\", 0, 0, \"class\"));\r\n    EXPECT_EQ(-1, ParseUtil::matchAt(\"\", 0, 0, \"\"));\r\n\r\n    constexpr char txt[] = \"aefvariable aowef \\n\";\r\n    EXPECT_EQ(-1, ParseUtil::matchAt(txt, sizeof(txt)-1, 2, \"false\"));\r\n\r\n\r\n    {\r\n        std::string class_text(u8\"     \\tclassauto * 😂日本語=10234;\");\r\n        int index = ParseUtil::matchAt(class_text.c_str(), class_text.length(), 0, \"class\");\r\n        EXPECT_EQ(index, 6);\r\n    }\r\n\r\n\r\n    {\r\n        std::string class_text(u8\"😂classauto;\");\r\n        int index = ParseUtil::matchAt(class_text.c_str(), class_text.length(), 0, \"class\");\r\n        EXPECT_EQ(index, -1);\r\n    }\r\n\r\n\r\n    // matchWord\r\n    {\r\n        std::string class_text(u8\"class\");\r\n        EXPECT_EQ(class_text.length(), 5);\r\n        auto result = ParseUtil::matchWord(class_text.c_str(), class_text.length(), \"class\", 5, 0);\r\n        EXPECT_EQ(result, true);\r\n    }\r\n\r\n    {\r\n        std::string class_text(u8\" class\"); //space\r\n        auto result = ParseUtil::matchWord(class_text.c_str(), class_text.length(), \"class\", 5, 0);\r\n        EXPECT_EQ(result, false);\r\n    }\r\n\r\n    {\r\n        std::string class_text(u8\"abcclass\");\r\n        auto result = ParseUtil::matchWord(class_text.c_str(), class_text.length(), \"class\", 5, 3);\r\n        EXPECT_EQ(result, true);\r\n    }\r\n\r\n    {\r\n        std::string class_text(u8\"classauto;\");\r\n        auto result = ParseUtil::matchWord(class_text.c_str(), class_text.length(), \"class\", 5, 0);\r\n        EXPECT_EQ(result, true);\r\n    }\r\n\r\n    {\r\n        std::string text(u8\"ab\");\r\n        auto result = ParseUtil::matchWord(text.c_str(), text.length(), \"abcdefg\", 5, 0);\r\n        EXPECT_EQ(result, false);\r\n    }\r\n\r\n\r\n\r\n    {\r\n        // endsWith\r\n        {\r\n            std::string text(u8\"ab\");\r\n            auto result = ParseUtil::endsWith2(text.c_str(), text.length(), \"ab\");\r\n            EXPECT_EQ(result, true);\r\n        }\r\n\r\n        {\r\n            std::string text(u8\"abcdefg\");\r\n            auto result = ParseUtil::endsWith2(text.c_str(), text.length(), \"efg\");\r\n            EXPECT_EQ(result, true);\r\n        }\r\n        {\r\n            std::string text(u8\"abcd\");\r\n            auto result = ParseUtil::endsWith2(text.c_str(), text.length(), \"aabcd\");\r\n            EXPECT_EQ(result, false);\r\n        }\r\n    }\r\n}\r\n\r\n"
	},
	{
		"testcasename": "ScriptEngine",
		"testname": "register_test2",
		"filepath": "tests/google_tests/script_runtime_test.cpp",
		"filename": "script_runtime_test.cpp",
		"body": "TEST(ScriptEngine, register_test2)\r\n    {\r\n        uint32_t num = 0;\r\n        __asm\r\n        {\r\n            mov ecx, 10; ecx = 10\r\n            mov eax, ecx; eax = ecx\r\n            add eax, ecx; eax = eax + ecx\r\n            mov num, eax;\r\n        }\r\n        EXPECT_EQ(num, 20);\r\n        "
	},
	{
		"testcasename": "ScriptEngine",
		"testname": "register_test",
		"filepath": "tests/google_tests/script_runtime_test.cpp",
		"filename": "script_runtime_test.cpp",
		"body": "TEST(ScriptEngine, register_test)\r\n    {\r\n        uint32_t num = UINT32_MAX;\r\n        unsigned short x = 0;\r\n        unsigned short y = 0;\r\n\r\n        __asm\r\n        {\r\n            mov eax, 0xFFFFFFFF;\r\n            mov ax, 0;\r\n            mov num, eax;\r\n        }\r\n        // mov esp, eax;\r\n        EXPECT_EQ(num, 0xFFFF0000);\r\n        "
	},
	{
		"testcasename": "ScriptEngine",
		"testname": "CPURegister_test1",
		"filepath": "tests/google_tests/script_runtime_test.cpp",
		"filename": "script_runtime_test.cpp",
		"body": "TEST(ScriptEngine, CPURegister_test1)\r\n    {\r\n        CPURegister reg{};\r\n        EXPECT_EQ(EAX(&reg), 0);\r\n        EXPECT_EQ(sizeof(reg.rax), 8);\r\n        EXPECT_EQ(sizeof(bool), 1);\r\n\r\n        RAX(&reg) = 0xFFFFFFFFFFFFFFFF;\r\n        AX(&reg) = 0;\r\n        EXPECT_EQ(RAX(&reg), 0xFFFFFFFFFFFF0000);\r\n\r\n\r\n        RAX(&reg) = 0xFFFFFFFFFFFFFFFF;\r\n        EAX(&reg) = 0x0;\r\n        EXPECT_EQ(RAX(&reg), 0xFFFFFFFF00000000);\r\n\r\n\r\n        EAX(&reg) = 0xFFFFFFFF;\r\n        AX(&reg) = 0;\r\n        EXPECT_EQ(EAX(&reg), 0xFFFF0000);\r\n\r\n\r\n        AX(&reg) = 0xFFFF;\r\n        AL(&reg) = 0x00;\r\n        EXPECT_EQ(AX(&reg), 0xFF00);\r\n\r\n        "
	},
	{
		"testcasename": "ScriptEngine",
		"testname": "MallocItem_test1",
		"filepath": "tests/google_tests/script_runtime_test.cpp",
		"filename": "script_runtime_test.cpp",
		"body": "TEST(ScriptEngine, MallocItem_test1)\r\n    {\r\n        ScriptEnv* env = ScriptEnv::newScriptEnv();\r\n\r\n        int* mem;\r\n        for (int i = 0; i < 1024; i++) {\r\n            mem = (int*)env->context->mallocItem(sizeof(int));\r\n            *mem = 53;\r\n\r\n            if (i % 3 == 2) {\r\n                env->context->freeItem(mem);\r\n            }\r\n        }\r\n\r\n        console_log(\"test\");\r\n\r\n        EXPECT_EQ(*mem, 53);\r\n        EXPECT_NE(env->context->memBufferForMalloc2.firstBufferBlock, env->context->memBufferForMalloc2.currentBufferBlock);\r\n\r\n        ScriptEnv::deleteScriptEnv(env);\r\n        "
	},
	{
		"testcasename": "ScriptEngine",
		"testname": "StackMemory_PushPop",
		"filepath": "tests/google_tests/script_runtime_test.cpp",
		"filename": "script_runtime_test.cpp",
		"body": "TEST(ScriptEngine, StackMemory_PushPop) {\r\n        ScriptEnv* env = ScriptEnv::newScriptEnv();\r\n\r\n        auto& stackMemory = env->context->stackMemory;\r\n        auto* stackPointer1 = stackMemory.stackPointer;\r\n\r\n        stackMemory.push(5);\r\n        stackMemory.push(6);\r\n        \r\n        EXPECT_NE((uint64_t)stackPointer1, (uint64_t)stackMemory.stackPointer);\r\n\r\n        EXPECT_EQ(6, stackMemory.pop());\r\n        EXPECT_EQ(5, stackMemory.pop());\r\n\r\n        EXPECT_EQ((uint64_t)stackPointer1, (uint64_t)stackMemory.stackPointer);\r\n\r\n\r\n        ScriptEnv::deleteScriptEnv(env);\r\n\r\n        "
	},
	{
		"testcasename": "ScriptEngine",
		"testname": "StackMemoryTest_Call_Ret",
		"filepath": "tests/google_tests/script_runtime_test.cpp",
		"filename": "script_runtime_test.cpp",
		"body": "TEST(ScriptEngine, StackMemoryTest_Call_Ret) {\r\n        ScriptEnv* env = ScriptEnv::newScriptEnv();\r\n\r\n        auto& stackMemory = env->context->stackMemory;\r\n        auto *basePointer0 = stackMemory.stackBasePointer;\r\n        auto *stackPointer0 = stackMemory.stackPointer;\r\n\r\n        stackMemory.call();\r\n        stackMemory.localVariables(8 * 4);\r\n        stackMemory.localVariables(8 * 4);\r\n        uint32_t a = 100;\r\n        uint32_t b;\r\n        stackMemory.moveTo(-4, 4, (st_byte*)&a);\r\n        stackMemory.moveFrom(-4, 4, (st_byte*)&b);\r\n        EXPECT_EQ(100, b);\r\n        stackMemory.ret();\r\n\r\n        EXPECT_EQ((uint64_t)basePointer0, (uint64_t)stackMemory.stackBasePointer);\r\n        EXPECT_EQ((uint64_t)stackPointer0, (uint64_t)stackMemory.stackPointer);\r\n\r\n        ScriptEnv::deleteScriptEnv(env);\r\n\r\n        "
	},
	{
		"testcasename": "ScriptEngine",
		"testname": "StackMemoryTest_cal_ret_2",
		"filepath": "tests/google_tests/script_runtime_test.cpp",
		"filename": "script_runtime_test.cpp",
		"body": "TEST(ScriptEngine, StackMemoryTest_cal_ret_2) {\r\n        ScriptEnv* env = ScriptEnv::newScriptEnv();\r\n\r\n        auto& stackMemory = env->context->stackMemory;\r\n\r\n        auto* basePointer0 = stackMemory.stackBasePointer;\r\n        auto* stackPointer0 = stackMemory.stackPointer;\r\n\r\n        // call func1\r\n        stackMemory.call();\r\n\r\n        stackMemory.push(8);\r\n        auto* stackPointer1 = stackMemory.stackPointer;\r\n        auto* basePointer1 = stackMemory.stackBasePointer;\r\n\r\n\r\n        // call func2\r\n        stackMemory.call();\r\n\r\n        stackMemory.localVariables(8 * 4);\r\n\r\n        stackMemory.ret();\r\n        // retruned from func2\r\n\r\n        EXPECT_EQ((uint64_t)basePointer1, (uint64_t)stackMemory.stackBasePointer);\r\n        EXPECT_EQ((uint64_t)stackPointer1, (uint64_t)stackMemory.stackPointer);\r\n\r\n        stackMemory.ret();\r\n        // returned from func1\r\n\r\n        EXPECT_EQ((uint64_t)basePointer0, (uint64_t)stackMemory.stackBasePointer);\r\n        EXPECT_EQ((uint64_t)stackPointer0, (uint64_t)stackMemory.stackPointer);\r\n\r\n        ScriptEnv::deleteScriptEnv(env);\r\n        \r\n        "
	},
	{
		"testcasename": "ScriptEngine",
		"testname": "StackMemoryTest_Overflow_Push",
		"filepath": "tests/google_tests/script_runtime_test.cpp",
		"filename": "script_runtime_test.cpp",
		"body": "TEST(ScriptEngine, StackMemoryTest_Overflow_Push) {\r\n        ScriptEnv* env = ScriptEnv::newScriptEnv();\r\n\r\n        auto& stackMemory = env->context->stackMemory;\r\n\r\n        for (int i = 0; i < stackMemory.stackSize/stackMemory.baseBytes - 1; i++) {\r\n            stackMemory.push(5);\r\n        }\r\n        EXPECT_EQ(stackMemory.isOverflowed, false);\r\n        stackMemory.push(5);\r\n\r\n        EXPECT_EQ(stackMemory.isOverflowed, true);\r\n\r\n        ScriptEnv::deleteScriptEnv(env);\r\n\r\n        "
	},
	{
		"testcasename": "ScriptEngine",
		"testname": "SktackMemoryTest_overflow_call",
		"filepath": "tests/google_tests/script_runtime_test.cpp",
		"filename": "script_runtime_test.cpp",
		"body": "TEST(ScriptEngine, SktackMemoryTest_overflow_call) {\r\n        ScriptEnv* env = ScriptEnv::newScriptEnv();\r\n\r\n        auto& stackMemory = env->context->stackMemory;\r\n\r\n        for (int i = 0; i < stackMemory.stackSize / stackMemory.baseBytes - 1; i++) {\r\n            stackMemory.call();\r\n        }\r\n        EXPECT_EQ(stackMemory.isOverflowed, false);\r\n        stackMemory.call();\r\n\r\n        EXPECT_EQ(stackMemory.isOverflowed, true);\r\n\r\n\r\n        ScriptEnv::deleteScriptEnv(env);\r\n\r\n        "
	},
	{
		"testcasename": "ScriptEngine",
		"testname": "StackMemoryTest_overflow_localVariables",
		"filepath": "tests/google_tests/script_runtime_test.cpp",
		"filename": "script_runtime_test.cpp",
		"body": "TEST(ScriptEngine, StackMemoryTest_overflow_localVariables) {\r\n        ScriptEnv* env = ScriptEnv::newScriptEnv();\r\n        auto& stackMemory = env->context->stackMemory;\r\n        \r\n        stackMemory.localVariables(stackMemory.stackSize);\r\n        EXPECT_EQ(stackMemory.isOverflowed, true);\r\n\r\n        ScriptEnv::deleteScriptEnv(env);\r\n\r\n        "
	},
	{
		"testcasename": "ScriptEngine",
		"testname": "ScriptEngineTestSomeScript0",
		"filepath": "tests/google_tests/script_runtime_test.cpp",
		"filename": "script_runtime_test.cpp",
		"body": "TEST(ScriptEngine, ScriptEngineTestSomeScript0) {\r\n\r\n        constexpr char source[] = R\"(\r\nfn main()\r\n{\r\n    int b = 9\r\n    int a = 500\r\n    int c = 500\r\n    \r\n    return c - (b + a)\r\n}\r\n)\";\r\n        int ret = ScriptEnv::startScript((char*)source, sizeof(source) - 1);\r\n        EXPECT_EQ(ret, -9);\r\n        EXPECT_EQ(1, sizeof(char));\r\n\r\n        "
	},
	{
		"testcasename": "ScriptEngine",
		"testname": "ScriptEngineTest_assign",
		"filepath": "tests/google_tests/script_runtime_test.cpp",
		"filename": "script_runtime_test.cpp",
		"body": "TEST(ScriptEngine, ScriptEngineTest_assign) {\r\n        constexpr char source[] = R\"(\r\nfn main()\r\n{\r\n    ?int *ptr = null\r\n    $int b = 9\r\n    b = (10 + 1) - 2\r\n    return b\r\n}\r\n)\";\r\n        int ret = ScriptEnv::startScript((char*)source, sizeof(source) - 1);\r\n        EXPECT_EQ(ret, 9);\r\n        "
	},
	{
		"testcasename": "ScriptEngine",
		"testname": "ScriptEngineTest_null",
		"filepath": "tests/google_tests/script_runtime_test.cpp",
		"filename": "script_runtime_test.cpp",
		"body": "TEST(ScriptEngine, ScriptEngineTest_null) {\r\n        constexpr char source[] = R\"(\r\nfn main()\r\n{\r\n    ?int *ptr = null\r\n    return ptr\r\n}\r\n)\";\r\n        int ret = ScriptEnv::startScript((char*)source, sizeof(source) - 1);\r\n        EXPECT_EQ(ret, 0);\r\n        "
	},
	{
		"testcasename": "ScriptEngine",
		"testname": "ScriptEngineTest_heapString",
		"filepath": "tests/google_tests/script_runtime_test.cpp",
		"filename": "script_runtime_test.cpp",
		"body": "TEST(ScriptEngine, ScriptEngineTest_heapString) {\r\n        constexpr char source[] = R\"(\r\nfn main()\r\n{\r\n    String *ptr = \"ijfowjio\"\r\n    String *ptr2 = ptr\r\n    return ptr2\r\n}\r\n)\";\r\n        int ret = ScriptEnv::startScript((char*)source, sizeof(source) - 1);\r\n        EXPECT_NE(ret, 0);\r\n        "
	},
	{
		"testcasename": "ScriptEngine",
		"testname": "ScriptEngineTest_sub",
		"filepath": "tests/google_tests/script_runtime_test.cpp",
		"filename": "script_runtime_test.cpp",
		"body": "TEST(ScriptEngine, ScriptEngineTest_sub) {\r\n        constexpr char source[] = R\"(\r\nfn main()\r\n{\r\n    let b = 9\r\n    int a = 5\r\n    int c = 5\r\n    \r\n    return c + b - a\r\n}\r\n)\";\r\n        int ret = ScriptEnv::startScript((char*)source, sizeof(source) - 1);\r\n        EXPECT_EQ(ret, 9);\r\n\r\n        "
	},
	{
		"testcasename": "ScriptEngine",
		"testname": "ScriptEngineTest_variable_to_variable",
		"filepath": "tests/google_tests/script_runtime_test.cpp",
		"filename": "script_runtime_test.cpp",
		"body": "TEST(ScriptEngine, ScriptEngineTest_variable_to_variable) {\r\n        constexpr char source[] = R\"(\r\nfn main()\r\n{\r\n    let b = 9\r\n    int c = b\r\n    \r\n    return c + b\r\n}\r\n)\";\r\n        int ret = ScriptEnv::startScript((char*)source, sizeof(source) - 1);\r\n        EXPECT_EQ(ret, 18);\r\n        "
	},
	{
		"testcasename": "ScriptEngine",
		"testname": "ScriptEngineTest_i64",
		"filepath": "tests/google_tests/script_runtime_test.cpp",
		"filename": "script_runtime_test.cpp",
		"body": "TEST(ScriptEngine, ScriptEngineTest_i64) {\r\n        constexpr char source[] = R\"(\r\nfn main()\r\n{\r\n    i64 b = 5L\r\n    i64 a = 900L\r\n    i64 c = 901L\r\n    \r\n    return c - (a + b)\r\n}\r\n)\";\r\n        ScriptEnv* env = ScriptEnv::loadScript((char*)source, sizeof(source) - 1);\r\n        if (env->document->context->syntaxErrorInfo.hasError) {\r\n            FAIL();\r\n            return;// env->document->context->syntaxErrorInfo.errorItem.errorId;\r\n        }\r\n\r\n        env->validateScript();\r\n        if (env->context->logicErrorInfo.hasError) {\r\n            FAIL();\r\n            env->context->setErrorPositions();\r\n            return;// env->context->logicErrorInfo.firstErrorItem->codeErrorItem.errorId;\r\n        }\r\n        auto* node = env->mainFunc->bodyNode.firstChildNode;\r\n        while (node) {\r\n            if (node->vtable == VTables::ReturnStatementVTable) {\r\n                auto returnState = Cast::downcast<ReturnStatementNodeStruct*>(node);\r\n                EXPECT_EQ(returnState->valueNode->vtable, VTables::BinaryOperationVTable);\r\n                auto binary0 = Cast::downcast<BinaryOperationNodeStruct*>(returnState->valueNode);\r\n\r\n                auto *c = Cast::downcast<VariableNodeStruct*>(binary0->leftExprNode);\r\n\r\n                auto pare = Cast::downcast<ParenthesesNodeStruct*>(binary0->rightExprNode);\r\n                EXPECT_EQ(pare->valueNode->vtable, VTables::BinaryOperationVTable);\r\n                auto binary = Cast::downcast<BinaryOperationNodeStruct*>(pare->valueNode);\r\n                auto *a = Cast::downcast<VariableNodeStruct*>(binary->leftExprNode);\r\n                auto *b = Cast::downcast<VariableNodeStruct*>(binary->rightExprNode);\r\n\r\n                // return c - (a + b)\r\n                EXPECT_EQ(c->calcRegEnum, PrimitiveCalcRegisterEnum::ebx);\r\n\r\n                EXPECT_EQ(a->calcRegEnum, PrimitiveCalcRegisterEnum::eax);\r\n                EXPECT_EQ(b->calcRegEnum, PrimitiveCalcRegisterEnum::ebx);\r\n                \r\n                EXPECT_EQ(binary->calcRegEnum, PrimitiveCalcRegisterEnum::ecx);\r\n                EXPECT_EQ(binary0->rightExprNode->calcRegEnum, PrimitiveCalcRegisterEnum::ecx);\r\n\r\n                // stack \r\n                EXPECT_EQ(c->stackOffset, -24);\r\n                EXPECT_EQ(a->stackOffset, -16);\r\n                EXPECT_EQ(b->stackOffset, -8);\r\n                EXPECT_EQ(env->mainFunc->stackSize, 24);\r\n            }\r\n            \r\n            node = node->nextNode;\r\n        }\r\n        int ret = env->runScriptEnv();\r\n        EXPECT_EQ(ret, -4);\r\n\r\n        //EXPECT_EQ(c - (a + b), 6);\r\n\r\n        "
	},
	{
		"testcasename": "SpeedTest",
		"testname": "memory_order_relaxed_is_fast",
		"filepath": "tests/google_tests/speed_test.cpp",
		"filename": "speed_test.cpp",
		"body": "TEST(SpeedTest, memory_order_relaxed_is_fast) {\r\n\r\n    EXPECT_EQ(true, ParseUtil::isIdentifierLetter('a'));\r\n\r\n\r\n    auto start = std::chrono::high_resolution_clock::now().time_since_epoch();\r\n\r\n    uint64_t loopCount = 1000 * 10 * 1000LLU;\r\n    std::atomic<uint64_t> *current = new std::atomic<uint64_t>();\r\n    current->store(9823, std::memory_order_relaxed);\r\n\r\n    //long kkk;\r\n    //P *p = new P();//uint64_t(33);\r\n    int *a = NULL;\r\n    int *newValue = new int{ 3 };\r\n\r\n    for (unsigned long long i = 0; i < loopCount; i++) {\r\n        if (i > 5) {\r\n            current->store(i, std::memory_order_relaxed);\r\n            a = newValue;\r\n            //InterlockedExchangePointerNoFence((PVOID *)&a, newValue);\r\n\r\n        }\r\n        else {\r\n            a = NULL;// newValue;\r\n        }\r\n        //current->compare_exchange_weak(loopCount, loopCount+1);\r\n\r\n        //p->a = static_cast<int>(i);\r\n        //do{} while(0); //noop\r\n//        kkk = current->load(std::memory_order_relaxed);\r\n    }\r\n\r\n    auto elapsed = std::chrono::high_resolution_clock::now().time_since_epoch() - start;\r\n    auto nanoseconds = std::chrono::duration_cast<std::chrono::nanoseconds>(elapsed).count();\r\n    auto one_op_nanosec = nanoseconds / static_cast<double>(loopCount);\r\n\r\n    if (a) {\r\n\r\n    }\r\n    if (speed_test) {\r\n        EXPECT_LT(one_op_nanosec, ARM ? 40 : 1.1);\r\n        printf(\"%f\", one_op_nanosec);\r\n    }\r\n    EXPECT_EQ(current->load(), loopCount - 1);\r\n}\r\n\r\n"
	},
	{
		"testcasename": "SpeedTest",
		"testname": "try_catch_is_slow",
		"filepath": "tests/google_tests/speed_test.cpp",
		"filename": "speed_test.cpp",
		"body": "TEST(SpeedTest, try_catch_is_slow) {\r\n\r\n    auto start = std::chrono::high_resolution_clock::now();\r\n\r\n    uint64_t loopCount = 1000 * 1000LLU;\r\n    int a = 0;\r\n\r\n    try {\r\n        for (int i = 0; i < loopCount; i++) {\r\n            a = i;\r\n        }\r\n    }\r\n    catch (...) {\r\n        std::exception_ptr p = std::current_exception();\r\n        printf(\"std::exception_ptr\\n\");\r\n\r\n    }\r\n\r\n    auto elapsed = std::chrono::high_resolution_clock::now() - start;\r\n    auto nanoseconds = std::chrono::duration_cast<std::chrono::nanoseconds>(elapsed).count();\r\n    auto one_op_nanosec = nanoseconds / static_cast<double>(loopCount);\r\n\r\n    // we have to use a once\r\n    printf(\"a = %d\", a);\r\n\r\n    if (ARM) {\r\n        EXPECT_LT(one_op_nanosec, 15);\r\n    } else {\r\n        EXPECT_GT(one_op_nanosec, 0.02);\r\n        EXPECT_LT(one_op_nanosec, 4);\r\n    }\r\n\r\n}\r\n\r\n"
	},
	{
		"testcasename": "SpeedTest",
		"testname": "stack_assign_is_fast",
		"filepath": "tests/google_tests/speed_test.cpp",
		"filename": "speed_test.cpp",
		"body": "TEST(SpeedTest, stack_assign_is_fast) {\r\n    {\r\n        auto start = std::chrono::high_resolution_clock::now();\r\n\r\n        const int64_t loopCount = 1000 *  1000LL;\r\n        int current = 0;//int{};\r\n        //auto *current2 = &aData->a;\r\n        int lim = loopCount - 15;\r\n        for (int i = 0; i < loopCount; i++) {\r\n            if (i > lim) {\r\n                current = i;\r\n            }\r\n        }\r\n\r\n        auto elapsed = std::chrono::high_resolution_clock::now() - start;\r\n        auto nanoseconds = std::chrono::duration_cast<std::chrono::nanoseconds>(elapsed).count();\r\n\r\n        auto one_op_nanosec = nanoseconds / static_cast<double>(loopCount);\r\n\r\n        GLOG << nanoseconds/1000000.0 << \"ms\";\r\n\r\n        EXPECT_LT(one_op_nanosec, ARM ? 10.0: 2.0);\r\n        EXPECT_EQ(current, loopCount - 1);\r\n        //EXPECT_EQ(*current2, loopCount - 1);\r\n    }\r\n#endif\r\n#ifdef  __MYWIN__\r\n\r\n    //_mm_pause() takes more than 0.5us\r\n   {\r\n       const auto start = std::chrono::high_resolution_clock::now();\r\n\r\n       int64_t max = 1000 * 100LL;\r\n       for (long long i = 0; i < max; i++) {\r\n           _mm_pause();\r\n       }\r\n\r\n       auto elapsed = std::chrono::high_resolution_clock::now() - start;\r\n       auto nano_elapsed = std::chrono::duration_cast<std::chrono::nanoseconds>(elapsed).count();\r\n\r\n       EXPECT_GT(nano_elapsed, max * 0.5);\r\n\r\n       if (os_type == OS_TYPE::Windows) {\r\n           EXPECT_LT(nano_elapsed, max * 90); // 90 nano seconds\r\n       }\r\n       else if (os_type == OS_TYPE::Mac) { // Mac\r\n           EXPECT_LT(nano_elapsed, max * 130);\r\n       }\r\n       else { // linux\r\n           EXPECT_LT(nano_elapsed, max * 90);//16\r\n       }\r\n\r\n   }\r\n#endif\r\n\r\n}\r\n\r\n"
	},
	{
		"testcasename": "SpeedTest",
		"testname": "functor",
		"filepath": "tests/google_tests/speed_test.cpp",
		"filename": "speed_test.cpp",
		"body": "TEST(SpeedTest, functor) {\r\n    /*\r\n    int var = Fx([&](const int x) {\r\n        int kk = 8;\r\n        return kk;\r\n    })(200);\r\n    */\r\n\r\n    //std::cout << \"argument function : \" << var << std::endl;\r\n\r\n    /*\r\n    auto gfunc = &fff_ori;\r\n    auto &&gfunc2 = gfunc;\r\n    auto result = (*gfunc2)(3);\r\n    SetStateProc(handle1);\r\n    auto state_proc2 = *state_proc;\r\n     */\r\n\r\n    //fff(5);\r\n    //auto fff_ori2 = gfunc;\r\n    //k2 = gfunc2(3);\r\n\r\n\r\n    //std::function<const int(const int)> &&fff = std::move(fff_ori);\r\n\r\n    //int k = state_proc2(3);\r\n    //int k = (*state_proc)(3);\r\n    //fff_ori(5);\r\n\r\n\r\n    EXPECT_EQ(10, 10);\r\n}\r\n\r\n"
	},
	{
		"testcasename": "SyntaxErrors",
		"testname": "JsonSyntaxError",
		"filepath": "tests/google_tests/syntax_error_tests.cpp",
		"filename": "syntax_error_tests.cpp",
		"body": "TEST(SyntaxErrors, JsonSyntaxError) {\r\n    // missing_object_delemeter\r\n    {\r\n        constexpr char text2[] = u8R\"(\r\n            {\"key\": \"value }\r\n)\";\r\n\r\n        TEST_JSON_SYNTAX_ERROR(text2, sizeof(text2) - 1, ErrorCode::missing_closing_quote);\r\n    }\r\n\r\n    // missing_object_delemeter\r\n    {\r\n        constexpr char text2[] = u8R\"(\r\n            {\"key\" \"value\"  }\r\n)\";\r\n\r\n        TEST_JSON_SYNTAX_ERROR(text2, sizeof(text2) - 1, ErrorCode::missing_object_delemeter);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\nstatic void testJsonSyntaxError(const char* codeText, int textlen, ErrorCode errorCode, const char* errorCodeText)\r\n{\r\n    auto* document = Alloc::newDocument(DocumentType::JsonDocument, nullptr);\r\n    DocumentUtils::parseText(document, codeText, textlen);\r\n\r\n\r\n    GLOG << std::endl  << \"------------------------------------------------------\" << std::endl;\r\n    GLOG << errorCodeText << std::endl;\r\n    GLOG << codeText << std::endl;\r\n\r\n    auto* context = document->context;\r\n    EXPECT_EQ(context->syntaxErrorInfo.hasError, true);\r\n    EXPECT_EQ(context->syntaxErrorInfo.errorItem.errorCode, errorCode);\r\n\r\n    Alloc::deleteDocument(document);\r\n}\r\n\r\nstatic void testSyntaxError(const char* codeText, int textlen, ErrorCode errorCode, const char* errorCodeText)\r\n{\r\n    auto* document = Alloc::newDocument(DocumentType::CodeDocument, nullptr);\r\n    DocumentUtils::parseText(document, codeText, textlen);\r\n\r\n\r\n    GLOG << std::endl << \"------------------------------------------------------\" << std::endl;\r\n    GLOG << errorCodeText << std::endl;\r\n    GLOG << codeText << std::endl;\r\n\r\n    auto* context = document->context;\r\n    EXPECT_EQ(context->syntaxErrorInfo.hasError, true);\r\n    EXPECT_EQ(context->syntaxErrorInfo.errorItem.errorCode, errorCode);\r\n\r\n    Alloc::deleteDocument(document);\r\n}\r\n\r\n\r\n"
	},
	{
		"testcasename": "SyntaxErrors",
		"testname": "CodeSyntaxError",
		"filepath": "tests/google_tests/syntax_error_tests.cpp",
		"filename": "syntax_error_tests.cpp",
		"body": "TEST(SyntaxErrors, CodeSyntaxError) {\r\n\r\n    // invalid_class_name\r\n    {\r\n        constexpr char text[] = u8R\"(\r\nclass {\r\n\r\n\r\n}\r\n)\";\r\n        TEST_SYNTAX_ERROR(text, sizeof(text) - 1, ErrorCode::invalid_class_name);\r\n    }\r\n\r\n\r\n    // no_brace_for_class\r\n    {\r\n        constexpr char code[] = u8R\"(\r\nclass A \r\n\r\n\r\n}\r\n)\";\r\n\r\n        TEST_SYNTAX_ERROR(code, sizeof(code) - 1, ErrorCode::no_brace_for_class);\r\n    }\r\n\r\n\r\n    // no_brace_of_end_for_class\r\n    {\r\n        constexpr char code[] = u8R\"(\r\nclass A {\r\n\r\n\r\n)\";\r\n        TEST_SYNTAX_ERROR(code, sizeof(code) - 1, ErrorCode::no_brace_of_end_for_class);\r\n\r\n        constexpr char code2[] = u8R\"(\r\nclass A {\r\n    class B {\r\n    }\r\n)\";\r\n        TEST_SYNTAX_ERROR(code2, sizeof(code2) - 1, ErrorCode::no_brace_of_end_for_class);\r\n\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n"
	},
	{
		"testcasename": "SyntaxErrors",
		"testname": "IndentSyntaxError",
		"filepath": "tests/google_tests/syntax_error_tests.cpp",
		"filename": "syntax_error_tests.cpp",
		"body": "TEST(SyntaxErrors, IndentSyntaxError) {\r\n\r\n    // indent syntax errors\r\n    {\r\n        constexpr char text[] = u8R\"(\r\nclass A {\r\n    /*\r\n   aa\r\n\r\n    */\r\n\r\n}\r\n)\";\r\n        TEST_SYNTAX_ERROR(text, sizeof(text) - 1, ErrorCode::indent_error);\r\n    }\r\n}\r\n\r\n\r\n"
	},
	{
		"testcasename": "TokenizersTest_",
		"testname": "StringLiteralTest",
		"filepath": "tests/google_tests/tokenizers_test.cpp",
		"filename": "tokenizers_test.cpp",
		"body": "TEST(TokenizersTest_, StringLiteralTest) {\r\n    auto text = const_cast<char *>(u8R\"(\r\n{\r\n    \"aowowo\" : 21249,\r\n})\");\r\n\r\n    auto *document = Alloc::newDocument(DocumentType::JsonDocument, nullptr);\r\n    auto* context = document->context;\r\n    DocumentUtils::parseText(document, text, strlen(text)); // for initialize a context\r\n\r\n    {\r\n        static constexpr const char class_chars[] = \"\\\"my text\\\"\";\r\n\r\n        context->length = sizeof(class_chars) - 1;;\r\n        context->chars = (char*)class_chars;\r\n        int result = Tokenizers::stringLiteralTokenizer(nullptr, class_chars[0], 0, context);\r\n\r\n        EXPECT_EQ(result, 9);\r\n        EXPECT_EQ(context->virtualCodeNode->vtable, VTables::StringLiteralVTable);\r\n        auto* stru = Cast::downcast<StringLiteralNodeStruct*>(context->virtualCodeNode);\r\n        EXPECT_EQ(std::string{ stru->str }, std::string{ \"my text\" });\r\n    }\r\n\r\n    {\r\n        static constexpr const char chars[] = u8R\"(\"A\\u864e\\u306e\\u0061\")\";\r\n\r\n        context->length = sizeof(chars) - 1;\r\n        context->chars = (char*)chars;\r\n        int result = Tokenizers::stringLiteralTokenizer(nullptr, chars[0], 0, context);\r\n\r\n        EXPECT_EQ(result, 21);\r\n        EXPECT_EQ(context->virtualCodeNode->vtable, VTables::StringLiteralVTable);\r\n\r\n        auto* stru = Cast::downcast<StringLiteralNodeStruct*>(context->virtualCodeNode);\r\n        EXPECT_EQ(stru->strLength, 8);\r\n        EXPECT_EQ(std::string{ stru->str }, std::string{ u8R\"(A虎のa)\" });\r\n\r\n        EXPECT_EQ(stru->textLength, 21);\r\n        EXPECT_EQ(std::string{ stru->text }, std::string{ u8R\"(\"A\\u864e\\u306e\\u0061\")\" });\r\n    }\r\n\r\n    {\r\n        static constexpr const char chars[] = u8\"\\\"\\\\r\\\\n\\\\t\\\\t\\\"\";\r\n\r\n        context->length = sizeof(chars) - 1;\r\n        context->chars = (char*)chars;\r\n        int result = Tokenizers::stringLiteralTokenizer(nullptr, chars[0], 0, context);\r\n\r\n        EXPECT_EQ(result, 10);\r\n        EXPECT_EQ(context->virtualCodeNode->vtable, VTables::StringLiteralVTable);\r\n\r\n        auto* stru = Cast::downcast<StringLiteralNodeStruct*>(context->virtualCodeNode);\r\n        EXPECT_EQ(stru->strLength, 4);\r\n        EXPECT_EQ(std::string{ stru->str }, std::string{ u8\"\\r\\n\\t\\t\" });\r\n\r\n        EXPECT_EQ(stru->textLength, 10);\r\n        EXPECT_EQ(std::string{ stru->text }, std::string{ u8\"\\\"\\\\r\\\\n\\\\t\\\\t\\\"\" });\r\n    }\r\n\r\n\r\n    Alloc::deleteDocument(document);\r\n}\r\n\r\n//static void testTokenizer(const char* codeText) {\r\n    //}\r\n//}\r\n\r\n\r\n"
	}
]